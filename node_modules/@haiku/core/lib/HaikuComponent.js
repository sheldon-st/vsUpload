"use strict";
/**
 * Copyright (c) Haiku 2016-2018. All rights reserved.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var api_1 = require("./api");
var Config_1 = require("./Config");
var HaikuBase_1 = require("./HaikuBase");
var HaikuElement_1 = require("./HaikuElement");
var HaikuHelpers_1 = require("./HaikuHelpers");
var HaikuNode_1 = require("./HaikuNode");
var HaikuTimeline_1 = require("./HaikuTimeline");
var ColorUtils_1 = require("./helpers/ColorUtils");
var consoleErrorOnce_1 = require("./helpers/consoleErrorOnce");
var interactionModes_1 = require("./helpers/interactionModes");
var isMutableProperty_1 = require("./helpers/isMutableProperty");
var KeyframeUtils_1 = require("./helpers/KeyframeUtils");
var PathUtils_1 = require("./helpers/PathUtils");
var SVGPoints_1 = require("./helpers/SVGPoints");
var Layout3D_1 = require("./Layout3D");
var Migration_1 = require("./Migration");
var enhance_1 = require("./reflection/enhance");
var functionToRFO_1 = require("./reflection/functionToRFO");
var StateTransitionManager_1 = require("./StateTransitionManager");
var Transitions_1 = require("./Transitions");
var assign_1 = require("./vendor/assign");
var invert_1 = require("./vendor/gl-mat4/invert");
var FUNCTION = 'function';
var KEYFRAME_ZERO = 0;
var OBJECT = 'object';
var MAX_INT = 2147483646;
var SCOPE_STRATA = { div: 'div', svg: 'svg' };
var CDN_ROOT_STR = 'HAIKU|CDN|PROJECT|ROOT'.split('|').join('_'); // Split to avoid server-side munging
// HACK: Required until DOM subtree-hydration race is fixed
var ALWAYS_UPDATED_PROPERTIES = { 'controlFlow.placeholder': true };
var parseD = function (value) {
    // in case of d="" for any reason, don't try to expand this otherwise this will choke
    // #TODO: arguably we should preprocess SVGs before things get this far; try svgo?
    if (!value || value.length === 0) {
        return [];
    }
    // Allow points to return an array for convenience, and let downstream marshal it
    if (Array.isArray(value)) {
        return value;
    }
    return SVGPoints_1.default.pathToPoints(value);
};
var generateD = function (value) {
    if (typeof value === 'string') {
        return value;
    }
    return SVGPoints_1.default.pointsToPath(value);
};
var parseColor = function (value) {
    return ColorUtils_1.default.parseString(value);
};
var generateColor = function (value) {
    return ColorUtils_1.default.generateString(value);
};
var parsePoints = function (value) {
    if (Array.isArray(value)) {
        return value;
    }
    return SVGPoints_1.default.polyPointsStringToPoints(value);
};
var generatePoints = function (value) {
    if (typeof value === 'string') {
        return value;
    }
    return SVGPoints_1.default.pointsToPolyString(value);
};
var isFunction = function (value) {
    return typeof value === FUNCTION;
};
var INJECTABLES = {};
var pkg = require('./../package.json');
exports.VERSION = pkg.version;
var STRING_TYPE = 'string';
var OBJECT_TYPE = 'object';
var HAIKU_ID_ATTRIBUTE = 'haiku-id';
var DEFAULT_TIMELINE_NAME = 'Default';
var CSS_QUERY_MAPPING = {
    name: 'elementName',
    attributes: 'attributes',
    children: 'children',
};
// tslint:disable:variable-name function-name
var HaikuComponent = /** @class */ (function (_super) {
    __extends(HaikuComponent, _super);
    function HaikuComponent(bytecode, context, host, config, container) {
        var _this = _super.call(this) || this;
        _this.parsedValueClusters = {};
        _this.needsExpand = true;
        _this.patches = [];
        if (!bytecode.template) {
            console.warn('[haiku core] adding missing template object');
            bytecode.template = { elementName: 'div', attributes: {}, children: [] };
        }
        if (!bytecode.timelines) {
            console.warn('[haiku core] adding missing timelines object');
            bytecode.timelines = {};
        }
        if (!bytecode.timelines[DEFAULT_TIMELINE_NAME]) {
            console.warn('[haiku core] adding missing default timeline');
            bytecode.timelines[DEFAULT_TIMELINE_NAME] = {};
        }
        if (!context) {
            throw new Error('Component requires a context');
        }
        if (!config) {
            throw new Error('Config options required');
        }
        if (!config.seed) {
            throw new Error('Seed value must be provided');
        }
        _this.PLAYER_VERSION = exports.VERSION; // #LEGACY
        _this.CORE_VERSION = exports.VERSION;
        _this.context = context;
        _this.container = container;
        _this.host = host;
        _this.guests = {};
        _this.bytecode = (config.hotEditingMode)
            ? bytecode
            : exports.clone(bytecode, _this); // Important because migrations mutate the bytecode
        assertTemplate(_this.bytecode.template);
        // Allow users to expose methods that can be called in event handlers
        if (_this.bytecode.methods) {
            for (var methodNameGiven in _this.bytecode.methods) {
                if (!_this[methodNameGiven]) {
                    _this[methodNameGiven] = _this.bytecode.methods[methodNameGiven].bind(_this);
                }
            }
        }
        _this._states = {}; // Storage for getter/setter actions in userland logic
        _this.state = {}; // Public accessor object, e.g. this.state.foo = 1
        // Instantiate StateTransitions. Responsible to store and execute any state transition.
        _this.stateTransitionManager = new StateTransitionManager_1.default(_this);
        _this.hooks = {};
        _this.helpers = Object.assign({}, _this.bytecode.helpers, {
            data: {},
        });
        // `assignConfig` calls bindStates because our incoming config, which
        // could occur at any point during runtime, e.g. in React, may need to update internal states, etc.
        // It also may populate hooks and helpers if passed in via configuration.
        _this.assignConfig(config);
        // Flag used internally to determine whether we need to re-render the full tree or can survive by just patching
        _this.doesNeedFullFlush = false;
        // If true, will continually flush the entire tree until explicitly set to false again
        _this.doAlwaysFlush = false;
        // If true, the component will assign 3D-preservation setting if one hasn't been set explicitly.
        // If config.preserve3d is 'auto', the migration pre-phase will try to detect whether 3d is needed.
        _this.doPreserve3d = (_this.config.preserve3d === true) ? true : false;
        // Dictionary of event handler names to handler functions; used to efficiently manage multiple subscriptions
        _this.registeredEventHandlers = {};
        // The last HaikuElement in this scope to be hovered; used to help manage hover/unhover
        _this.lastHoveredElement = null;
        // Flag to determine whether this component should continue doing any work
        _this.isDeactivated = false;
        // Flag to indicate whether we are sleeping, an ephemeral condition where no rendering occurs
        _this.isSleeping = false;
        _this.helpers = {
            data: {},
        };
        var helpers = Object.assign({}, HaikuHelpers_1.default.helpers, _this.getHelpers());
        for (var helperName in helpers) {
            _this.helpers[helperName] = helpers[helperName];
        }
        _this.helpers.now = function () {
            if (_this.isLiveMode()) {
                return (_this.config.timestamp || 1) + (_this.helpers.data.lastTimelineTime || 1);
            }
            return 1;
        };
        _this.helpers.rand = function () {
            if (_this.isLiveMode()) {
                var scopeKey = [
                    _this.helpers.data.lastTimelineName,
                    _this.helpers.data.lastTimelineTime,
                    _this.helpers.data.lastPropertyName,
                    _this.helpers.data.lastFlexId,
                ].join('|');
                var randKey = _this.config.seed + "@" + scopeKey;
                var keyInt = stringToInt(randKey);
                var outFloat = ((keyInt + 1) % MAX_INT) / MAX_INT;
                return outFloat;
            }
            return 1;
        };
        _this.helpers.find = function (selector) {
            return _this.querySelectorAll(selector);
        };
        var migrationOptions = {
            attrsHyphToCamel: exports.ATTRS_HYPH_TO_CAMEL,
            // During editing, we handle mutations directly in the app.
            mutations: config.hotEditingMode ? undefined : {
                // Random seed for adding instance uniqueness to ids at runtime.
                referenceUniqueness: (config.hotEditingMode)
                    ? undefined // During editing, Haiku.app pads ids unless this is undefined
                    : Math.random().toString(36).slice(2),
                haikuRoot: _this.getProjectRootPathWithTerminatingSlash(),
            },
        };
        try {
            Migration_1.runMigrationsPrePhase(_this, migrationOptions);
        }
        catch (exception) {
            console.warn('[haiku core] caught error during migration pre-phase', exception);
        }
        // Ensure full tree is are properly set up and all render nodes are connected to their models
        _this.render(__assign({}, _this.config));
        try {
            // If the bytecode we got happens to be in an outdated format, we automatically update it to the latest.
            Migration_1.runMigrationsPostPhase(_this, migrationOptions, exports.VERSION);
        }
        catch (exception) {
            console.warn('[haiku core] caught error during migration post-phase', exception);
        }
        _this.hydrateMutableTimelines();
        if (!_this.host) {
            _this.routeEventToHandlerAndEmit(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:did-initialize', [_this]);
        }
        else {
            _this.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:did-initialize', [_this]);
        }
        // #FIXME: some handlers may still reference `_bytecode` directly.
        _this._bytecode = _this.bytecode;
        return _this;
    }
    /**
     * @description Track elements that are at the horizon of what we want to render, i.e., a list of
     * virtual elements that we don't want to make any updates lower than in the tree.
     */
    HaikuComponent.prototype.markHorizonElement = function (virtualElement) {
        if (virtualElement && virtualElement.attributes) {
            virtualElement.__horizon = true;
        }
    };
    /**
     * @description Returns true/false whether this element is one that we don't want to make any
     *  updates further down its tree.
     */
    HaikuComponent.prototype.isHorizonElement = function (virtualElement) {
        if (virtualElement && virtualElement.attributes) {
            return virtualElement.__horizon;
        }
        return false;
    };
    HaikuComponent.prototype.isLiveMode = function () {
        return interactionModes_1.isLiveMode(this.config.interactionMode);
    };
    HaikuComponent.prototype.isEditMode = function () {
        return !this.isLiveMode();
    };
    HaikuComponent.prototype.registerGuest = function (subcomponent) {
        this.guests[subcomponent.getId()] = subcomponent;
    };
    HaikuComponent.prototype.visitGuestHierarchy = function (visitor) {
        visitor(this, this.$id, this.host);
        for (var $id in this.guests) {
            this.guests[$id].visitGuestHierarchy(visitor);
        }
    };
    HaikuComponent.prototype.visitGuests = function (visitor) {
        for (var $id in this.guests) {
            visitor(this.guests[$id], $id);
        }
    };
    // If the component needs to remount itself for some reason, make sure we fire the right events
    HaikuComponent.prototype.callRemount = function (incomingConfig, skipMarkForFullFlush) {
        var _this = this;
        if (skipMarkForFullFlush === void 0) { skipMarkForFullFlush = false; }
        this.visitGuestHierarchy(function (guest) {
            if (guest === _this) {
                guest.routeEventToHandlerAndEmit(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:will-mount', [guest]);
            }
            else {
                guest.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:will-mount', [guest]);
            }
        });
        // Note!: Only update config if we actually got incoming options!
        if (incomingConfig) {
            this.assignConfig(incomingConfig);
        }
        if (!skipMarkForFullFlush) {
            this.markForFullFlush();
            this.clearCaches(null);
        }
        // If autoplay is not wanted, stop the all timelines immediately after we've mounted
        // (We have to mount first so that the component displays, but then pause it at that state.)
        // If you don't want the component to show up at all, use options.automount=false.
        var timelineInstances = this.getTimelines();
        for (var timelineName in timelineInstances) {
            var timelineInstance = timelineInstances[timelineName];
            if (this.config.autoplay) {
                if (timelineName === DEFAULT_TIMELINE_NAME) {
                    // Assume we want to start the timeline from the beginning upon remount.
                    // NOTE:
                    // timeline.play() will normally trigger markForFullFlush because it assumes we need to render
                    // from the get-go. However, in case of a callRemount, we might not want to do that since it can be kind of
                    // like running the first frame twice. So we pass the option into play so it can conditionally skip the
                    // markForFullFlush step.
                    if (!timelineInstance.isPaused()) {
                        timelineInstance.play({ skipMarkForFullFlush: skipMarkForFullFlush });
                    }
                }
            }
            else {
                timelineInstance.pause();
            }
        }
        this.context.contextMount();
        this.visitGuestHierarchy(function (guest) {
            if (guest === _this) {
                guest.routeEventToHandlerAndEmit(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:did-mount', [guest]);
            }
            else {
                guest.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:did-mount', [guest]);
            }
        });
    };
    HaikuComponent.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        // Destroy all timelines we host.
        var timelineInstances = this.getTimelines();
        for (var timelineName in timelineInstances) {
            var timelineInstance = timelineInstances[timelineName];
            timelineInstance.destroy();
        }
        this.visitGuestHierarchy(function (component) {
            // Clean up HaikuComponent dependents.
            // TODO: is this step necessary?
            if (component !== _this) {
                component.destroy();
            }
        });
        this.visitDescendants(function (child) {
            // Clean up HaikuElement dependents.
            child.destroy();
        });
    };
    HaikuComponent.prototype.callUnmount = function () {
        var _this = this;
        // Since we're unmounting, pause all animations to avoid unnecessary calc while detached
        var timelineInstances = this.getTimelines();
        for (var timelineName in timelineInstances) {
            var timelineInstance = timelineInstances[timelineName];
            timelineInstance.pause();
        }
        this.context.contextUnmount();
        this.visitGuestHierarchy(function (guest) {
            if (guest === _this) {
                guest.routeEventToHandlerAndEmit(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:will-unmount', [guest]);
            }
            else {
                guest.routeEventToHandlerAndEmitWithoutBubbling(HaikuBase_1.GLOBAL_LISTENER_KEY, 'component:will-unmount', [guest]);
            }
        });
    };
    HaikuComponent.prototype.assignConfig = function (incomingConfig) {
        this.config = Config_1.default.build(this.config || {}, incomingConfig || {});
        // Don't assign the context config if we're a guest component;
        // assume only the top-level component should have this power
        if (this.host) {
            // Don't forget to update the configuration values shared by the context,
            // but skip component assignment so we don't end up in an infinite loop
            this.context.assignConfig(this.config, { skipComponentAssign: true });
        }
        var timelines = this.getTimelines();
        for (var name_1 in timelines) {
            var timeline = timelines[name_1];
            timeline.assignOptions(this.config);
        }
        this.bindStates();
        assign_1.default(this.hooks, this.config.hooks);
        assign_1.default(this.helpers, this.config.helpers);
        assign_1.default(this.bytecode.timelines, this.config.timelines);
        return this;
    };
    HaikuComponent.prototype.set = function (key, value) {
        this.callHook('state:change', { state: key, from: this.state[key], to: value });
        this.state[key] = value;
        return this;
    };
    HaikuComponent.prototype.get = function (key) {
        return this.state[key];
    };
    HaikuComponent.prototype.setState = function (states, transitionParameter) {
        // Do not set any state if invalid
        if (!states || typeof states !== 'object') {
            return this;
        }
        // Set states is delegated to stateTransitionManager
        this.stateTransitionManager.setState(states, transitionParameter);
        return this;
    };
    HaikuComponent.prototype.getStates = function () {
        return this.state;
    };
    HaikuComponent.prototype.clearCaches = function (options) {
        if (options === void 0) { options = {}; }
        // HaikuBase implements a general-purpose caching mechanism which we also call here
        this.cacheClear();
        this.needsExpand = true;
        // Don't forget to repopulate the states with originals when we clear cache
        if (options.clearStates) {
            this.clearStates();
        }
        this.hydrateMutableTimelines();
        this.parsedValueClusters = {};
        // Our managed timeline instances may have their own privately cached properties
        var timelines = this.fetchTimelines();
        for (var timelineName in timelines) {
            timelines[timelineName].cacheClear();
        }
    };
    HaikuComponent.prototype.cacheNodeWithSelectorKey = function (node) {
        if (!node || typeof node !== 'object') {
            return;
        }
        if (node.attributes && node.attributes[HAIKU_ID_ATTRIBUTE]) {
            var selector = "haiku:" + node.attributes[HAIKU_ID_ATTRIBUTE];
            var key = this.nodesCacheKey(selector);
            var collection = this.cacheGet(key) || [];
            if (collection.indexOf(node) === -1) {
                collection.push(node);
            }
            this.cacheSet(key, collection);
        }
    };
    HaikuComponent.prototype.clearStates = function () {
        this._states = {};
        this.bindStates();
    };
    HaikuComponent.prototype.getClock = function () {
        return this.context.clock;
    };
    HaikuComponent.prototype.getTemplate = function () {
        return this.bytecode.template;
    };
    HaikuComponent.prototype.getHelpers = function () {
        return this.bytecode.helpers;
    };
    HaikuComponent.prototype.getTimelines = function () {
        var _this = this;
        return this.cacheFetch('getTimelines', function () {
            return _this.fetchTimelines();
        });
    };
    HaikuComponent.prototype.fetchTimelines = function () {
        var names = Object.keys(this.bytecode.timelines);
        for (var i = 0; i < names.length; i++) {
            var name_2 = names[i];
            if (!name_2) {
                continue;
            }
            var existing = HaikuTimeline_1.default.where({
                name: name_2,
                component: this,
            })[0];
            if (!existing) {
                HaikuTimeline_1.default.create(this, name_2, this.config);
            }
        }
        var out = {};
        var timelines = HaikuTimeline_1.default.where({ component: this });
        for (var j = 0; j < timelines.length; j++) {
            var timeline = timelines[j];
            out[timeline.getName()] = timeline;
        }
        return out;
    };
    HaikuComponent.prototype.getTimeline = function (name) {
        return this.getTimelines()[name];
    };
    HaikuComponent.prototype.fetchTimeline = function (name, descriptor) {
        var found = this.getTimeline(name);
        if (found) {
            return found;
        }
        return HaikuTimeline_1.default.create(this, name, this.config);
    };
    HaikuComponent.prototype.getDefaultTimeline = function () {
        var timelines = this.getTimelines();
        return timelines[DEFAULT_TIMELINE_NAME];
    };
    HaikuComponent.prototype.stopAllTimelines = function () {
        var timelines = this.getTimelines();
        for (var name_3 in timelines) {
            this.stopTimeline(name_3);
        }
    };
    HaikuComponent.prototype.startAllTimelines = function () {
        var timelines = this.getTimelines();
        for (var name_4 in timelines) {
            this.startTimeline(name_4);
        }
    };
    HaikuComponent.prototype.startTimeline = function (timelineName) {
        var descriptor = this.getTimelineDescriptor(timelineName);
        var existing = this.fetchTimeline(timelineName, descriptor);
        if (existing) {
            existing.start();
        }
    };
    HaikuComponent.prototype.stopTimeline = function (timelineName) {
        var descriptor = this.getTimelineDescriptor(timelineName);
        var existing = this.fetchTimeline(timelineName, descriptor);
        if (existing) {
            existing.stop();
        }
    };
    /**
     * @description Convenience alias for HaikuTimeline#gotoAndPlay
     */
    HaikuComponent.prototype.gotoAndPlay = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        this.getDefaultTimeline().gotoAndPlay(amount, unit);
    };
    /**
     * @description Convenience alias for HaikuTimeline#gotoAndStop
     */
    HaikuComponent.prototype.gotoAndStop = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        this.getDefaultTimeline().gotoAndStop(amount, unit);
    };
    /**
     * @description Convenience alias for HaikuTimeline#pause
     */
    HaikuComponent.prototype.pause = function () {
        this.getDefaultTimeline().pause();
    };
    /**
     * @description Convenience alias for HaikuTimeline#stop
     */
    HaikuComponent.prototype.stop = function () {
        this.getDefaultTimeline().stop();
    };
    /**
     * @description Convenience alias for HaikuTimeline#seek
     */
    HaikuComponent.prototype.seek = function (amount, unit) {
        if (unit === void 0) { unit = "fr" /* Frame */; }
        this.getDefaultTimeline().seek(amount, unit);
    };
    /**
     * @description Convenience alias for HaikuTimeline#start
     */
    HaikuComponent.prototype.start = function () {
        this.getDefaultTimeline().start();
    };
    /**
     * @description Convenience alias for HaikuTimeline#play
     */
    HaikuComponent.prototype.play = function (options) {
        if (options === void 0) { options = {}; }
        this.getDefaultTimeline().play();
    };
    HaikuComponent.prototype.getTimelineDescriptor = function (timelineName) {
        return this.bytecode.timelines[timelineName];
    };
    HaikuComponent.prototype.getInjectables = function () {
        var injectables = {};
        assign_1.default(injectables, this.getSummonablesSchema());
        // Local states get precedence over global summonables, so assign them last
        for (var key in this._states) {
            var type = this._states[key] && this._states[key].type;
            if (!type) {
                type = typeof this._states[key];
            }
            injectables[key] = type;
        }
        return injectables;
    };
    /**
     * @method _deactivate
     * @description When hot-reloading a component during editing, this can be used to
     * ensure that this component doesn't keep updating after its replacement is loaded.
     */
    HaikuComponent.prototype.deactivate = function () {
        this.isDeactivated = true;
    };
    HaikuComponent.prototype.activate = function () {
        this.isDeactivated = false;
    };
    HaikuComponent.prototype.sleepOn = function () {
        this.isSleeping = true;
    };
    HaikuComponent.prototype.sleepOff = function () {
        this.isSleeping = false;
    };
    /**
     * @method dump
     * @description Dump serializable info about this object
     */
    HaikuComponent.prototype.dump = function () {
        var metadata = this.getBytecodeMetadata();
        return metadata.relpath + ":" + this.getComponentId();
    };
    HaikuComponent.prototype.getBytecodeMetadata = function () {
        return this.bytecode.metadata;
    };
    HaikuComponent.prototype.getBytecodeRelpath = function () {
        var metadata = this.getBytecodeMetadata();
        return metadata && metadata.relpath;
    };
    HaikuComponent.prototype.getBytecodeProject = function () {
        var metadata = this.getBytecodeMetadata();
        return metadata && metadata.project;
    };
    HaikuComponent.prototype.getBytecodeOrganization = function () {
        var metadata = this.getBytecodeMetadata();
        return metadata && metadata.organization;
    };
    HaikuComponent.prototype.getAddressableProperties = function (out) {
        var _this = this;
        if (out === void 0) { out = {}; }
        if (!this.bytecode.states) {
            return out;
        }
        var _loop_2 = function (name_5) {
            var state = this_1.bytecode.states[name_5];
            out[name_5] = {
                name: name_5,
                type: 'state',
                prefix: name_5,
                suffix: undefined,
                fallback: state.value,
                typedef: state.type,
                mock: state.mock,
                target: this_1,
                value: function () {
                    return _this.state[name_5]; // The current live value of this state as seen by the app
                },
            };
        };
        var this_1 = this;
        for (var name_5 in this.bytecode.states) {
            _loop_2(name_5);
        }
        return out;
    };
    HaikuComponent.prototype.bindStates = function () {
        var allStates = assign_1.default({}, this.bytecode.states, this.config.states);
        for (var stateSpecName in allStates) {
            var stateSpec = allStates[stateSpecName];
            // 'null' is the signal for an empty prop, not undefined.
            if (!stateSpec || stateSpec.value === undefined) {
                console.error('Property `' +
                    stateSpecName +
                    '` cannot be undefined; use null for empty states');
                continue;
            }
            if (!this._states.hasOwnProperty(stateSpecName) || this.config.states.hasOwnProperty(stateSpecName)) {
                this._states[stateSpecName] = stateSpec.value;
                this.defineSettableState(stateSpec, stateSpecName);
            }
        }
    };
    HaikuComponent.prototype.defineSettableState = function (stateSpec, stateSpecName) {
        var _this = this;
        // Note: We define the getter/setter on the object itself, but the storage occurs on the pass-in statesTargetObject
        Object.defineProperty(this.state, stateSpecName, {
            configurable: true,
            enumerable: true,
            get: function () {
                return _this._states[stateSpecName];
            },
            set: function (inputValue) {
                if (stateSpec.setter) {
                    // Important: We call the setter with a binding of the component, so it can access methods on `this`
                    _this._states[stateSpecName] = stateSpec.setter.call(_this, inputValue);
                }
                else {
                    _this._states[stateSpecName] = inputValue;
                }
                if (!_this.isDeactivated) {
                    _this.emit('state:set', stateSpecName, _this._states[stateSpecName]);
                }
                return _this._states[stateSpecName];
            },
        });
    };
    HaikuComponent.prototype.allEventHandlers = function () {
        return assign_1.default({}, this.bytecode.eventHandlers, this.config.eventHandlers);
    };
    HaikuComponent.prototype.eachEventHandler = function (iteratee) {
        var eventHandlers = this.allEventHandlers();
        for (var eventSelector in eventHandlers) {
            for (var eventName in eventHandlers[eventSelector]) {
                var descriptor = eventHandlers[eventSelector][eventName];
                if (!descriptor || !descriptor.handler) {
                    continue;
                }
                iteratee(eventSelector, eventName, descriptor);
            }
        }
    };
    HaikuComponent.prototype.routeEventToHandler = function (eventSelectorGiven, eventNameGiven, eventArgs) {
        var _this = this;
        if (this.isDeactivated) {
            return;
        }
        this.eachEventHandler(function (eventSelector, eventName, _a) {
            var handler = _a.handler;
            if (eventNameGiven === eventName) {
                if (eventSelectorGiven === eventSelector ||
                    eventSelectorGiven === HaikuBase_1.GLOBAL_LISTENER_KEY) {
                    _this.callEventHandler(eventSelector, eventName, handler, eventArgs);
                    return;
                }
            }
        });
    };
    HaikuComponent.prototype.setHook = function (hookName, hookFn) {
        this.hooks[hookName] = hookFn;
    };
    HaikuComponent.prototype.callHook = function (hookName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a;
        if (typeof this.hooks[hookName] === 'function') {
            (_a = this.hooks)[hookName].apply(_a, args);
        }
    };
    HaikuComponent.prototype.callEventHandler = function (eventsSelector, eventName, handler, eventArgs) {
        // Only fire the event listeners if the component is in 'live' interaction mode,
        // i.e., not currently being edited inside the Haiku authoring environment
        // However, some components rely on specific event hooks firing in Edit mode, too â€” they can
        // whitelist their "edit mode" event names through `options`
        if (!this.isLiveMode() &&
            !(this.bytecode.options &&
                this.bytecode.options.editModeEvents &&
                this.bytecode.options.editModeEvents[eventName])) {
            return;
        }
        this.callHook('action:before', this, eventName, eventsSelector, eventArgs);
        try {
            handler.apply(this, [this].concat(eventArgs));
        }
        catch (exception) {
            consoleErrorOnce_1.default(exception);
        }
        this.callHook('action:after', this, eventName, eventsSelector, eventArgs);
    };
    HaikuComponent.prototype.routeEventToHandlerAndEmit = function (eventSelectorGiven, eventNameGiven, eventArgs) {
        if (this.isDeactivated) {
            return;
        }
        this.routeEventToHandler(eventSelectorGiven, eventNameGiven, eventArgs);
        this.emit.apply(this, [eventNameGiven].concat(eventArgs));
    };
    HaikuComponent.prototype.routeEventToHandlerAndEmitWithoutBubbling = function (eventSelectorGiven, eventNameGiven, eventArgs) {
        if (this.isDeactivated) {
            return;
        }
        this.routeEventToHandler(eventSelectorGiven, eventNameGiven, eventArgs);
        this.emitWithoutBubbling.apply(this, [eventNameGiven].concat(eventArgs));
    };
    HaikuComponent.prototype.routeEventToHandlerAndEmitWithoutBubblingAndWithoutGlobalHandlers = function (eventSelectorGiven, eventNameGiven, eventArgs) {
        if (this.isDeactivated) {
            return;
        }
        this.routeEventToHandler(eventSelectorGiven, eventNameGiven, eventArgs);
        this.emitToListeners(eventNameGiven, eventArgs);
        this.emitToGenericListeners(eventNameGiven, eventArgs);
    };
    /**
     * @description A more expressive form of `emit` that allows the user to route
     * events to specific collections of elements/components in the tree using labels,
     * selectors, etc. This method is provided in lieu of providing an individual method
     * for every possible topology.
     */
    HaikuComponent.prototype.send = function (route, name) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        // Send to parent
        if (route === 'emit' ||
            route === 'up' ||
            route === 'parent' ||
            route === '<' // Cute: '>' is the opposite of CSS children selector '<'
        ) {
            this.emit.apply(this, [name].concat(args));
            return;
        }
        // Send to children
        if (route === 'down' ||
            route === 'children' ||
            route === '>' // CSS children selector
        ) {
            this.visitGuests(function (guest) {
                guest.emitWithoutBubbling.apply(guest, [name].concat(args));
            });
            return;
        }
        // Send to siblings
        if (route === 'sideways' ||
            route === 'siblings' ||
            route === '~' // CSS sibling selector
        ) {
            if (this.host) {
                this.host.visitGuests(function (guest) {
                    if (guest !== _this) {
                        guest.emitWithoutBubbling.apply(guest, [name].concat(args));
                    }
                });
            }
            return;
        }
        // Send to everyone
        if (route === '*') {
            this.top.visitGuestHierarchy(function (guest) {
                if (guest !== _this) {
                    guest.emitWithoutBubbling.apply(guest, [name].concat(args));
                }
            });
        }
    };
    HaikuComponent.prototype.emitToAncestors = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.host) {
            // 1. Emit to listeners on the "wrapper" div
            this.host.routeEventToHandler("haiku:" + exports.getNodeCompositeId(this.parentNode), name, [this].concat(args));
            // 2. For convenience, emit to listeners on the root component of the hosts
            this.host.routeEventToHandler("haiku:" + exports.getNodeCompositeId(this.host), name, [this].concat(args));
        }
    };
    HaikuComponent.prototype.emitWithoutBubbling = function (key) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.routeEventToHandler(HaikuBase_1.GLOBAL_LISTENER_KEY, key, args);
        this.emitToListeners(key, args);
        this.emitToGenericListeners(key, args);
    };
    HaikuComponent.prototype.markForFullFlush = function () {
        this.doesNeedFullFlush = true;
    };
    HaikuComponent.prototype.unmarkForFullFlush = function () {
        this.doesNeedFullFlush = false;
    };
    HaikuComponent.prototype.shouldPerformFullFlush = function () {
        return this.doesNeedFullFlush || this.doAlwaysFlush;
    };
    HaikuComponent.prototype.expandIfNeeded = function () {
        if (this.needsExpand) {
            expandNode(this.bytecode.template, this.container);
            this.needsExpand = false;
        }
    };
    HaikuComponent.prototype.performFullFlushRenderWithRenderer = function (renderer, options) {
        if (options === void 0) { options = {}; }
        this.context.getContainer(true); // Force recalc of container
        // Since we will produce a full tree, we don't need a further full flush.
        this.unmarkForFullFlush();
        this.needsExpand = true;
        this.render(options);
        // Untyped code paths downstream depend on the output of this method
        return renderer.render(this.container, this.bytecode.template, this);
    };
    HaikuComponent.prototype.performPatchRenderWithRenderer = function (renderer, options, skipCache) {
        if (options === void 0) { options = {}; }
        if (renderer.shouldCreateContainer) {
            this.context.getContainer(true); // Force recalc of container
        }
        var patches = this.patch(options, skipCache);
        renderer.patch(this, patches);
        for (var $id in this.guests) {
            var guest = this.guests[$id];
            if (guest.shouldPerformFullFlush() && guest.target) {
                guest.performFullFlushRenderWithRenderer(renderer, options);
            }
            else {
                guest.performPatchRenderWithRenderer(renderer, options, skipCache);
            }
        }
    };
    HaikuComponent.prototype.render = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // We register ourselves with our host here because render is guaranteed to be called
        // both in our constructor and in the case that we were deactivated/reactivated.
        // This must run before the isDeactivated check since we may use the registry to activate later.
        if (this.host) {
            this.host.registerGuest(this);
        }
        if (this.isDeactivated) {
            // If deactivated, pretend like there is nothing to render
            return;
        }
        this.clearCaches();
        HaikuElement_1.default.findOrCreateByNode(this.container);
        if (!this.container.__memory.subcomponent) {
            // A semantically different thing than .subcomponent/.instance
            this.container.__memory.containee = this;
        }
        hydrateNode(this.bytecode.template, // node
        this.container, // parent
        this, // instance (component)
        this.context, this.host, 'div', // scope (the default is a div)
        options, true);
        this.applyLocalBehaviors(false, // isPatchOperation
        false);
        if (this.context.renderer.mount) {
            this.eachEventHandler(function (eventSelector, eventName) {
                var registrationKey = eventSelector + ":" + eventName;
                if (_this.registeredEventHandlers[registrationKey]) {
                    return;
                }
                _this.registeredEventHandlers[registrationKey] = true;
                _this.context.renderer.mountEventListener(_this, eventSelector, eventName, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    _this.routeEventToHandlerAndEmit(eventSelector, eventName, args);
                });
            });
        }
        this.applyGlobalBehaviors(options);
        // But also note we need to call subcomponent renders *after* our own behaviors,
        // because we need the parent-to-child states to be set prior to this render call,
        // otherwise the changes they produce won't be available for this render frame.
        for (var $id in this.guests) {
            this.guests[$id].render(__assign({}, this.guests[$id].config, Config_1.default.buildChildSafeConfig(options)));
        }
        this.expandIfNeeded();
        return this.bytecode.template;
    };
    HaikuComponent.prototype.patch = function (options, skipCache) {
        if (options === void 0) { options = {}; }
        if (skipCache === void 0) { skipCache = false; }
        if (this.isDeactivated) {
            // If deactivated, pretend like there is nothing to render
            return {};
        }
        this.applyLocalBehaviors(true, // isPatchOperation
        skipCache);
        this.applyGlobalBehaviors(options);
        var patches = {};
        this.expandIfNeeded();
        for (var i = 0; i < this.patches.length; i++) {
            var node = this.patches[i];
            computeAndApplyLayout(node, node.__memory.parent);
            patches[exports.getNodeCompositeId(node)] = node;
        }
        this.patches = [];
        return patches;
    };
    HaikuComponent.prototype.applyGlobalBehaviors = function (options) {
        if (options === void 0) { options = {}; }
        if (!this.host && options.sizing) {
            var didSizingChange = computeAndApplyPresetSizing(this.bytecode.template, this.container, options.sizing);
            if (didSizingChange) {
                this.patches.push(this.bytecode.template);
            }
        }
    };
    HaikuComponent.prototype.applyLocalBehaviors = function (isPatchOperation, skipCache) {
        if (skipCache === void 0) { skipCache = false; }
        var globalClockTime = this.context.clock.getExplicitTime();
        var manaTree = this.manaTreeCached();
        for (var timelineName in this.bytecode.timelines) {
            var timelineInstance = this.getTimeline(timelineName);
            timelineInstance.executePreUpdateHooks(globalClockTime);
            var timelineTime = timelineInstance.getTime(); // Bounded time
            var timelineDescriptor = this.bytecode.timelines[timelineName];
            var mutableTimelineDescriptor = isPatchOperation
                ? this.mutableTimelines[timelineName]
                : timelineDescriptor;
            if (!mutableTimelineDescriptor) {
                mutableTimelineDescriptor = {};
            }
            for (var behaviorSelector in mutableTimelineDescriptor) {
                var matchingElementsForBehavior = this.findMatchingNodesByCSSSelector(manaTree, behaviorSelector);
                if (!matchingElementsForBehavior || matchingElementsForBehavior.length < 1) {
                    continue;
                }
                var propertiesGroup = mutableTimelineDescriptor[behaviorSelector];
                if (!propertiesGroup) {
                    continue;
                }
                // This is our opportunity to group property operations that need to be in order
                var propertyOperations = collatePropertyGroup(propertiesGroup);
                for (var i = 0; i < matchingElementsForBehavior.length; i++) {
                    var matchingElement = matchingElementsForBehavior[i];
                    var compositeId = exports.getNodeCompositeId(matchingElement);
                    for (var j = 0; j < propertyOperations.length; j++) {
                        var propertyGroup = propertyOperations[j];
                        for (var propertyName in propertyGroup) {
                            var keyframeCluster = propertyGroup[propertyName];
                            var grabbedValue = this.grabValue(timelineName, compositeId, matchingElement, propertyName, keyframeCluster, timelineTime, isPatchOperation, skipCache);
                            var computedValue = grabbedValue.computedValue, didValueChangeSinceLastRequest = grabbedValue.didValueChangeSinceLastRequest, didValueOriginateFromExplicitKeyframeDefinition = grabbedValue.didValueOriginateFromExplicitKeyframeDefinition;
                            if (computedValue === undefined) {
                                continue;
                            }
                            // We always apply the property if...
                            if (
                            // - This is a full render
                            !isPatchOperation ||
                                // - The value in question has changed
                                didValueChangeSinceLastRequest ||
                                // - The value is in the whitelist of always-updated properties
                                ALWAYS_UPDATED_PROPERTIES[propertyName] ||
                                (
                                // - The value was explicitly defined as a keyframe and...
                                didValueOriginateFromExplicitKeyframeDefinition && (
                                // - We haven't yet reached the end
                                (timelineTime < timelineInstance.getMaxTime()) ||
                                    // - The timeline is looping (we won't be hanging on the final keyframe)
                                    timelineInstance.isLooping() ||
                                    // - We just reached the final keyframe (but haven't already visited it)
                                    timelineInstance.getLastFrame() !== timelineInstance.getBoundedFrame()))) {
                                this.applyPropertyToNode(matchingElement, propertyName, computedValue, timelineInstance);
                                if (isPatchOperation) {
                                    this.patches.push(matchingElement);
                                }
                            }
                        }
                    }
                }
            }
            timelineInstance.executePostUpdateHooks(globalClockTime);
        }
    };
    HaikuComponent.prototype.getProjectRootPathWithTerminatingSlash = function () {
        var metadata = this.getBytecodeMetadata();
        // If root is set and is not precisely this known magic string,
        // assume the root actually defines a root path somewhere on the web we can resolve to.
        if (metadata && metadata.root && metadata.root !== CDN_ROOT_STR) {
            return metadata.root;
        }
        // Try to use a locally defined folder (i.e. during editing in Haiku),
        // or fallback to a local path and hope we resolve to something meaningful.
        return this.config.folder || (metadata && metadata.folder) || './';
    };
    HaikuComponent.prototype.applyPropertyToNode = function (node, name, value, timeline) {
        var sender = (node.__memory.instance) ? node.__memory.instance : this; // Who sent the command
        var receiver = node.__memory.subcomponent;
        var type = (receiver && receiver.tagName) || node.elementName;
        var addressables = receiver && receiver.getAddressableProperties();
        var addressee = addressables && addressables[name] !== undefined && receiver;
        if (addressee) {
            // Note: Even though we apply the value to addressables of the subcomponent,
            // we still proceed with application of properties directly to the wrapper.
            // This is as a convenience, so that if a subcomponent wants to handle any property
            // applied to its wrapper than it can do so, e.g. sizeAbsolute.x/sizeAbsolute.y.
            addressee.set(name, value);
        }
        var vanity = exports.getVanity(type, name);
        if (vanity) {
            return vanity(name, node, value, this.context, timeline, receiver, sender);
        }
        var parts = name.split('.');
        if (parts[0] === 'style' && parts[1]) {
            return setStyle(parts[1], node, value);
        }
        return setAttribute(name, node, value);
    };
    HaikuComponent.prototype.findElementsByHaikuId = function (componentId) {
        return this.findMatchingNodesByCSSSelector(this.manaTreeCached(), "haiku:" + componentId);
    };
    HaikuComponent.prototype.nodesCacheKey = function (selector) {
        return 'nodes:' + selector;
    };
    HaikuComponent.prototype.manaTreeCached = function () {
        var _this = this;
        return this.cacheFetch('flatManaTree', function () { return HaikuNode_1.manaFlattenTree(_this.bytecode.template, CSS_QUERY_MAPPING); });
    };
    HaikuComponent.prototype.findMatchingNodesByCSSSelector = function (manaTree, selector) {
        var nodes = this.cacheFetch(this.nodesCacheKey(selector), function () { return HaikuNode_1.cssQueryList(manaTree, selector, CSS_QUERY_MAPPING); });
        var out = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var repeatees = findRespectiveRepeatees(node);
            // If the node in question is the descendant of a repeater, we need to find all repeated
            // copies of it inside the host repeater. If any repeatees are returned that means the
            // element is in fact a repeater, otherwise it is not a repeater, so just use the node.
            if (repeatees.length > 0) {
                out.push.apply(out, repeatees);
            }
            else {
                out.push(node);
            }
        }
        return out;
    };
    HaikuComponent.prototype.hydrateMutableTimelines = function () {
        this.mutableTimelines = {};
        if (this.bytecode.timelines) {
            for (var timelineName in this.bytecode.timelines) {
                for (var selector in this.bytecode.timelines[timelineName]) {
                    for (var propertyName in this.bytecode.timelines[timelineName][selector]) {
                        if (isMutableProperty_1.default(this.bytecode.timelines[timelineName][selector][propertyName], propertyName)) {
                            if (!this.mutableTimelines[timelineName]) {
                                this.mutableTimelines[timelineName] = {};
                            }
                            if (!this.mutableTimelines[timelineName][selector]) {
                                this.mutableTimelines[timelineName][selector] = {};
                            }
                            this.mutableTimelines[timelineName][selector][propertyName] =
                                this.bytecode.timelines[timelineName][selector][propertyName];
                        }
                    }
                }
            }
        }
    };
    HaikuComponent.prototype.addHotComponent = function (hotComponent) {
        if (!this.bytecode.timelines ||
            !this.bytecode.timelines[hotComponent.timelineName] ||
            !this.bytecode.timelines[hotComponent.timelineName][hotComponent.selector]) {
            return;
        }
        var propertyGroup = this.bytecode.timelines[hotComponent.timelineName][hotComponent.selector];
        if (!this.mutableTimelines[hotComponent.timelineName]) {
            this.mutableTimelines[hotComponent.timelineName] = {};
        }
        if (!this.mutableTimelines[hotComponent.timelineName][hotComponent.selector]) {
            this.mutableTimelines[hotComponent.timelineName][hotComponent.selector] = {};
        }
        Object.assign(this.mutableTimelines[hotComponent.timelineName][hotComponent.selector], hotComponent.propertyNames.reduce(function (hotProperties, propertyName) { return (hotProperties[propertyName] = propertyGroup[propertyName], hotProperties); }, {}));
    };
    HaikuComponent.prototype.controlTime = function (timelineName, timelineTime) {
        var explicitTime = this.context.clock.getExplicitTime();
        var timelineInstances = this.getTimelines();
        for (var localTimelineName in timelineInstances) {
            if (localTimelineName === timelineName) {
                var timelineInstance = timelineInstances[timelineName];
                timelineInstance.controlTime(timelineTime, explicitTime);
            }
        }
        for (var $id in this.guests) {
            this.guests[$id].controlTime(timelineName, 0);
        }
    };
    HaikuComponent.prototype.getPropertiesGroup = function (timelineName, flexId) {
        return (this.bytecode &&
            this.bytecode.timelines &&
            this.bytecode.timelines[timelineName] &&
            this.bytecode.timelines[timelineName]["haiku:" + flexId]);
    };
    /**
     * Execute state transitions.
     */
    HaikuComponent.prototype.tickStateTransitions = function () {
        this.stateTransitionManager.tickStateTransitions();
    };
    /**
     * Reset states to initial values by using State Transitions. Default to linear
     */
    HaikuComponent.prototype.resetStatesToInitialValuesWithTransition = function (duration, curve) {
        if (curve === void 0) { curve = api_1.Curve.Linear; }
        // Build initial states
        var initialStates = assign_1.default({}, this.bytecode.states, this.config.states);
        for (var key in initialStates) {
            initialStates[key] = initialStates[key].value;
        }
        // Create state transition to initial state values
        this.stateTransitionManager.setState(initialStates, { curve: curve, duration: duration });
    };
    Object.defineProperty(HaikuComponent.prototype, "top", {
        /**
         * @description Get the topmost component in the hierarchy.
         */
        get: function () {
            if (this.host) {
                return this.host.top;
            }
            return this;
        },
        enumerable: true,
        configurable: true
    });
    HaikuComponent.prototype.getRootComponent = function () {
        if (this.host) {
            return this.host.getRootComponent();
        }
        return this;
    };
    HaikuComponent.prototype.emitFromRootComponent = function (eventName, attachedObject) {
        this.getRootComponent().emit(eventName, __assign({}, attachedObject, { componentTitle: this.title }));
    };
    HaikuComponent.prototype.evaluate = function (expr) {
        // Make all injectables available within the scope of the function we'll create below,
        // so users can freely evaluate an expression like this.evaluate('$user.mouse.x');
        try {
            // tslint:disable-next-line:no-function-constructor-with-string-args
            var fn = new Function('$children', '$clock', '$component', '$container', '$context', '$core', '$element', '$host', '$if', '$index', '$mount', '$parent', '$payload', '$placeholder', '$repeat', '$state', '$timeline', '$top', '$tree', '$user', '$window', "return " + expr + ";\n");
            return fn(this.summon('$children'), this.summon('$clock'), this.summon('$component'), this.summon('$container'), this.summon('$context'), this.summon('$core'), this.summon('$element'), this.summon('$host'), this.summon('$if'), this.summon('$index'), this.summon('$mount'), this.summon('$parent'), this.summon('$payload'), this.summon('$placeholder'), this.summon('$repeat'), this.summon('$state'), this.summon('$timeline'), this.summon('$top'), this.summon('$tree'), this.summon('$user'), this.summon('$window'));
        }
        catch (exception) {
            console.warn("[haiku core] could not evaluate " + expr, exception);
        }
    };
    HaikuComponent.prototype.summon = function (injectable) {
        if (INJECTABLES[injectable] && INJECTABLES[injectable].summon) {
            var out = {};
            INJECTABLES[injectable].summon(out, // injectees
            this, // component
            this.bytecode.template, // node
            DEFAULT_TIMELINE_NAME);
            return out[injectable];
        }
    };
    HaikuComponent.prototype.evaluateExpression = function (fn, timelineName, flexId, matchingElement, propertyName, keyframeMs, keyframeCluster) {
        enhance_1.default(fn, null);
        // We'll store the result of this evaluation in this variable
        // (so we can cache it in case unexpected subsequent calls)
        var evaluation;
        if (fn.specification === true) {
            // This function is of an unknown kind, so just evaluate it normally without magic dependency injection
            evaluation = safeCall(fn, this, this._states);
        }
        else if (!Array.isArray(fn.specification.params)) {
            // If for some reason we got a non-array params, just evaluate
            evaluation = safeCall(fn, this, this._states);
        }
        else if (fn.specification.params.length < 1) {
            // If for some reason we got 0 params, just evaluate it
            evaluation = safeCall(fn, this, this._states);
        }
        else {
            if (fn.specification.params.length < 1) {
                // If the summon isn't in the destructured object format, just evaluate it
                evaluation = safeCall(fn, this, this._states);
            }
            else {
                var summoneesArray = this.summonSummonables(fn.specification.params, timelineName, flexId, matchingElement, propertyName, keyframeMs, keyframeCluster);
                var previousSummoneesArray = this.getPreviousSummonees(timelineName, flexId, propertyName, keyframeMs);
                if (areSummoneesDifferent(previousSummoneesArray, summoneesArray)) {
                    this.cacheSummonees(timelineName, flexId, propertyName, keyframeMs, summoneesArray);
                    evaluation = safeApply(fn, this, summoneesArray);
                }
                else {
                    // Since nothing is different, return the previous evaluation
                    evaluation = this.getPreviousEvaluation(timelineName, flexId, propertyName, keyframeMs);
                }
            }
        }
        // If the output is literally `NaN`, that is almost certainly useless and not what the user
        // intended. This can happen commonly when editing in Haiku.app and creating dynamic behavior
        // based on state payloads whose fields may be missing, especially with controlFlow.repeat.
        if (Number.isNaN(evaluation)) {
            evaluation = 1;
        }
        // Same for Infinity; as it's more likely than not that this is a mistake
        if (typeof evaluation === 'number' && !isFinite(evaluation)) {
            evaluation = 1;
        }
        // Store the result so we can return it on the next run without re-eval
        if (fn.specification && fn.specification !== true) {
            this.cacheEvaluation(timelineName, flexId, propertyName, keyframeMs, evaluation);
        }
        return evaluation;
    };
    HaikuComponent.prototype.summonSummonables = function (paramsArray, timelineName, flexId, matchingElement, propertyName, keyframeMs, keyframeCluster) {
        var summonablesArray = [];
        // Temporary storage, just creating one object here to avoid excessive allocations
        var summonStorage = {};
        for (var i = 0; i < paramsArray.length; i++) {
            var summonsEntry = paramsArray[i];
            // We'll store the output of the summons in this var, whether we're dealing with
            // a complex nested summonable or a flat one
            var summonsOutput = void 0;
            // In case of a string, we will treat it as the key for the object to summon
            if (typeof summonsEntry === 'string') {
                // Treat the entry as the key to a known injectable
                if (INJECTABLES[summonsEntry]) {
                    summonStorage[summonsEntry] = undefined; // Clear out the old value before populating with the new one
                    INJECTABLES[summonsEntry].summon(summonStorage, this, matchingElement, timelineName);
                    summonsOutput = summonStorage[summonsEntry];
                }
                else {
                    summonsOutput = this.state[summonsEntry];
                }
            }
            // Whatever the request format was, populate the result in here
            if (summonsOutput !== undefined) {
                summonablesArray[i] = summonsOutput;
            }
        }
        return summonablesArray;
    };
    HaikuComponent.prototype.fetchParsedValueCluster = function (timelineName, flexId, matchingElement, outputName, cluster, isPatchOperation, skipCache) {
        var parseeWithKeys = this.getParseeWithKeys(timelineName, flexId, outputName, cluster);
        if (!cluster) {
            return parseeWithKeys;
        }
        var skipStableParsees = isPatchOperation && !skipCache;
        if (skipStableParsees && this.clusterParseeIsStable(parseeWithKeys)) {
            return parseeWithKeys;
        }
        for (var i = 0; i < parseeWithKeys.keys.length; i++) {
            var ms = parseeWithKeys.keys[i];
            var descriptor = cluster[ms];
            if ((skipStableParsees && parseeWithKeys.parsee[ms] && !parseeWithKeys.parsee[ms].expression) ||
                descriptor === undefined) {
                continue;
            }
            if (isFunction(descriptor.value)) {
                parseeWithKeys.parsee[ms] = {
                    expression: true,
                    value: this.evaluateExpression(descriptor.value, timelineName, flexId, matchingElement, outputName, ms, cluster),
                };
            }
            else {
                parseeWithKeys.parsee[ms] = {
                    expression: false,
                    value: descriptor.value,
                };
            }
            if (descriptor.curve) {
                parseeWithKeys.parsee[ms].curve = descriptor.curve;
            }
        }
        if (parseeWithKeys.keys.length > 1) {
            var parser = this.getParser(outputName);
            if (!parser &&
                // tslint:disable-next-line:triple-equals
                parseFloat(parseeWithKeys.parsee[parseeWithKeys.keys[0]].value) ==
                    parseeWithKeys.parsee[parseeWithKeys.keys[0]].value) {
                parser = parseFloat;
            }
            if (!parser) {
                return parseeWithKeys;
            }
            for (var j = 0; j < parseeWithKeys.keys.length; j++) {
                var ms2 = parseeWithKeys.keys[j];
                parseeWithKeys.parsee[ms2].value = parser(parseeWithKeys.parsee[ms2].value);
            }
            if (outputName === 'd') {
                PathUtils_1.synchronizePathStructure.apply(void 0, parseeWithKeys.keys.map(function (ms) { return parseeWithKeys.parsee[ms].value; }));
            }
        }
        return parseeWithKeys;
    };
    HaikuComponent.prototype.generateFinalValueFromParsedValue = function (timelineName, flexId, matchingElement, outputName, computedValue) {
        if (computedValue === undefined) {
            return;
        }
        var generator = this.getGenerator(outputName);
        if (generator) {
            return generator(computedValue);
        }
        return computedValue;
    };
    HaikuComponent.prototype.grabValue = function (timelineName, flexId, matchingElement, propertyName, keyframeCluster, timelineTime, isPatchOperation, skipCache) {
        // Used by $helpers to calculate scope-specific values;
        this.helpers.data = {
            lastTimelineName: timelineName,
            lastFlexId: flexId,
            lastPropertyName: propertyName,
            lastTimelineTime: timelineTime,
        };
        var parsedValueCluster = this.fetchParsedValueCluster(timelineName, flexId, matchingElement, propertyName, keyframeCluster, isPatchOperation, skipCache);
        // If there is no property of that name, we would have gotten nothing back, so we can't forward this to Transitions
        // since it expects to receive a populated cluster object
        if (!parsedValueCluster) {
            return {
                computedValue: undefined,
                didValueChangeSinceLastRequest: false,
                didValueOriginateFromExplicitKeyframeDefinition: false,
            };
        }
        var computedValueForTime;
        if (!parsedValueCluster.parsee[KEYFRAME_ZERO]) {
            parsedValueCluster.parsee[KEYFRAME_ZERO] = {
                value: exports.getFallback(matchingElement && matchingElement.elementName, propertyName),
            };
        }
        computedValueForTime = Transitions_1.calculateValue(parsedValueCluster.parsee, timelineTime, parsedValueCluster.keys);
        // When expressions and other dynamic functionality is in play, data may be missing resulting in
        // properties lacking defined values; in this case we try to do the right thing and fallback
        // to a known usable value for the field. Especially needed with controlFlow.repeat.
        if (computedValueForTime === undefined) {
            computedValueForTime = exports.getFallback(matchingElement && matchingElement.elementName, propertyName);
        }
        var computedValue = this.generateFinalValueFromParsedValue(timelineName, flexId, matchingElement, propertyName, computedValueForTime);
        var previousValue = this.cacheGet("values:" + timelineName + "|" + flexId + "|" + propertyName);
        this.cacheSet("values:" + timelineName + "|" + flexId + "|" + propertyName, computedValue);
        var didValueChangeSinceLastRequest = computedValue !== previousValue;
        return {
            computedValue: computedValue,
            didValueChangeSinceLastRequest: didValueChangeSinceLastRequest,
            didValueOriginateFromExplicitKeyframeDefinition: keyframeCluster && !!keyframeCluster[Math.round(timelineTime)],
        };
    };
    HaikuComponent.prototype.getPreviousSummonees = function (timelineName, flexId, propertyName, keyframeMs) {
        return this.cacheGet("summonees:" + timelineName + "|" + flexId + "|" + propertyName + "|" + keyframeMs);
    };
    HaikuComponent.prototype.cacheSummonees = function (timelineName, flexId, propertyName, keyframeMs, summonees) {
        this.cacheSet("summonees:" + timelineName + "|" + flexId + "|" + propertyName + "|" + keyframeMs, summonees);
        return summonees;
    };
    HaikuComponent.prototype.getPreviousEvaluation = function (timelineName, flexId, propertyName, keyframeMs) {
        return this.cacheGet("evaluation:" + timelineName + "|" + flexId + "|" + propertyName + "|" + keyframeMs);
    };
    HaikuComponent.prototype.cacheEvaluation = function (timelineName, flexId, propertyName, keyframeMs, evaluation) {
        this.cacheSet("evaluation:" + timelineName + "|" + flexId + "|" + propertyName + "|" + keyframeMs, evaluation);
        return evaluation;
    };
    HaikuComponent.prototype.getParseeWithKeys = function (timelineName, flexId, outputName, cluster) {
        if (!this.parsedValueClusters[timelineName]) {
            this.parsedValueClusters[timelineName] = {};
        }
        if (!this.parsedValueClusters[timelineName][flexId]) {
            this.parsedValueClusters[timelineName][flexId] = {};
        }
        if (!this.parsedValueClusters[timelineName][flexId][outputName]) {
            this.parsedValueClusters[timelineName][flexId][outputName] = {
                // The parsee object is mutated in place downstream
                parsee: {},
                keys: cluster ? KeyframeUtils_1.getSortedKeyframes(cluster) : [],
            };
        }
        return this.parsedValueClusters[timelineName][flexId][outputName];
    };
    HaikuComponent.prototype.clusterParseeIsStable = function (parsedValueCluster) {
        return parsedValueCluster.keys.every(function (ms) { return parsedValueCluster.parsee[ms] && !parsedValueCluster.parsee[ms].expression; });
    };
    HaikuComponent.prototype.didChangeValue = function (timelineName, flexId, matchingElement, outputName, outputValue) {
        var answer = false;
        var change = this.cacheGet("changes:" + timelineName + "|" + flexId + "|" + outputName);
        if (change === undefined || change !== outputValue) {
            this.cacheSet("changes:" + timelineName + "|" + flexId + "|" + outputName, outputValue);
            answer = true;
        }
        return answer;
    };
    HaikuComponent.prototype.getSummonablesSchema = function () {
        var summonablesSchema = {};
        for (var key in INJECTABLES) {
            summonablesSchema[key] = INJECTABLES[key].schema;
        }
        return summonablesSchema;
    };
    HaikuComponent.prototype.transformContextPointToLocalPoint = function (point) {
        if (this.layoutAncestryMatrices) {
            var matrix = Layout3D_1.default.multiplyArrayOfMatrices(this.layoutAncestryMatrices.reverse());
            var inverse = invert_1.default([], matrix);
            if (inverse !== null) {
                HaikuElement_1.default.transformPointInPlace(point, inverse);
            }
        }
        return point;
    };
    HaikuComponent.prototype.getParser = function (outputName) {
        var foundParser = HaikuComponent.PARSERS[outputName];
        return foundParser && foundParser.parse;
    };
    HaikuComponent.prototype.getGenerator = function (outputName) {
        var foundGenerator = HaikuComponent.PARSERS[outputName];
        return foundGenerator && foundGenerator.generate;
    };
    HaikuComponent.__name__ = 'HaikuComponent';
    HaikuComponent.PLAYER_VERSION = exports.VERSION; // #LEGACY
    HaikuComponent.CORE_VERSION = exports.VERSION;
    HaikuComponent.INJECTABLES = INJECTABLES;
    // When editing a component, any of these appearing inside an expression will trigger a warning.
    // This is kept in the core so it's easier to compare these to the built-in injectables and
    // other special treatment for JavaScript globals. "single source of truth" etc.
    HaikuComponent.FORBIDDEN_EXPRESSION_TOKENS = {
        // Keywords
        new: true,
        this: true,
        with: true,
        delete: true,
        export: true,
        extends: true,
        super: true,
        class: true,
        abstract: true,
        interface: true,
        static: true,
        label: true,
        goto: true,
        private: true,
        import: true,
        public: true,
        // Future keywords
        do: true,
        native: true,
        package: true,
        transient: true,
        implements: true,
        protected: true,
        throws: true,
        synchronized: true,
        final: true,
        // Common globals
        window: true,
        document: true,
        global: true,
        // Danger
        eval: true,
        uneval: true,
        Function: true,
        EvalError: true,
        // Module stuff to forbid
        require: true,
        module: true,
        exports: true,
        Module: true,
        // Sandbox
        arguments: true,
        callee: true,
        // Identifiers on built-in global objects
        prototpye: true,
        __proto__: true,
        freeze: true,
        setPrototypeOf: true,
        constructor: true,
        defineProperties: true,
        defineProperty: true,
    };
    HaikuComponent.PARSERS = {
        'style.stroke': { parse: parseColor, generate: generateColor },
        'style.fill': { parse: parseColor, generate: generateColor },
        'style.backgroundColor': { parse: parseColor, generate: generateColor },
        'style.borderBottomColor': { parse: parseColor, generate: generateColor },
        'style.borderColor': { parse: parseColor, generate: generateColor },
        'style.borderLeftColor': { parse: parseColor, generate: generateColor },
        'style.borderRightColor': { parse: parseColor, generate: generateColor },
        'style.borderTopColor': { parse: parseColor, generate: generateColor },
        'style.floodColor': { parse: parseColor, generate: generateColor },
        'style.lightingColor': { parse: parseColor, generate: generateColor },
        'style.stopColor': { parse: parseColor, generate: generateColor },
        stroke: { parse: parseColor, generate: generateColor },
        fill: { parse: parseColor, generate: generateColor },
        floodColor: { parse: parseColor, generate: generateColor },
        lightingColor: { parse: parseColor, generate: generateColor },
        stopColor: { parse: parseColor, generate: generateColor },
        backgroundColor: { parse: parseColor, generate: generateColor },
        animateColor: { parse: parseColor, generate: generateColor },
        feColor: { parse: parseColor, generate: generateColor },
        // Note the hyphenated duplicates, for convenience
        'flood-color': { parse: parseColor, generate: generateColor },
        'lighting-color': { parse: parseColor, generate: generateColor },
        'stop-color': { parse: parseColor, generate: generateColor },
        'background-color': { parse: parseColor, generate: generateColor },
        'animate-color': { parse: parseColor, generate: generateColor },
        'fe-color': { parse: parseColor, generate: generateColor },
        d: { parse: parseD, generate: generateD },
        points: { parse: parsePoints, generate: generatePoints },
    };
    HaikuComponent.all = function () { return HaikuBase_1.default.getRegistryForClass(HaikuComponent); };
    return HaikuComponent;
}(HaikuElement_1.default));
exports.default = HaikuComponent;
var getNodeFlexId = function (node) {
    var domId = (node &&
        node.attributes &&
        node.attributes.id);
    var haikuId = (node &&
        node.attributes &&
        node.attributes[HAIKU_ID_ATTRIBUTE]);
    return haikuId || domId;
};
exports.getNodeCompositeId = function (node) {
    var flexId = getNodeFlexId(node);
    // Treat the 0th repeater as the original (source) element
    return (node.__memory && node.__memory.repeatee && node.__memory.repeatee.index)
        ? flexId + "'" + node.__memory.repeatee.index
        : flexId;
};
var collatePropertyGroup = function (propertiesGroup) {
    var collation = [
        {},
        {},
        {},
        {},
    ];
    for (var propertyName in propertiesGroup) {
        if (propertyName === 'controlFlow.if') {
            collation[0][propertyName] = propertiesGroup[propertyName];
        }
        else if (propertyName === 'controlFlow.repeat') {
            collation[1][propertyName] = propertiesGroup[propertyName];
        }
        else if (propertyName === 'controlFlow.placeholder') {
            collation[2][propertyName] = propertiesGroup[propertyName];
        }
        else {
            collation[3][propertyName] = propertiesGroup[propertyName];
        }
    }
    return collation;
};
function isBytecode(thing) {
    return thing && typeof thing === OBJECT_TYPE && thing.template;
}
function assertTemplate(template) {
    if (!template) {
        throw new Error('Empty template not allowed');
    }
    if (typeof template === OBJECT_TYPE) {
        if (template.attributes) {
            if (!template.attributes[HAIKU_ID_ATTRIBUTE]) {
                console.warn('[haiku core] bytecode template has no id');
            }
        }
        else {
            console.warn('[haiku core] bytecode template has no attributes');
        }
        if (!template.elementName) {
            console.warn('[haiku core] unexpected bytecode template format');
        }
        return template;
    }
    throw new Error('Unknown bytecode template format');
}
var needsVirtualChildren = function (child) { return typeof child === 'object' &&
    child.__memory &&
    ((child.__memory.if && !child.__memory.if.answer) ||
        (child.__memory.repeater && !!child.__memory.repeater.repeatees)); };
var reduceNodeMemoryChildren = function (children, out, doIncludeRepeatees) {
    if (out === void 0) { out = []; }
    if (doIncludeRepeatees === void 0) { doIncludeRepeatees = false; }
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (!child) {
            continue;
        }
        if (typeof child === 'object' && child.__memory) {
            // Do not include any children that have been removed due to $if-logic
            if (child.__memory.if && !child.__memory.if.answer) {
                continue;
            }
            // If the child is a repeater, use the $repeats instead of itself
            if (doIncludeRepeatees &&
                child.__memory.repeater &&
                child.__memory.repeater.repeatees) {
                reduceNodeMemoryChildren(child.__memory.repeater.repeatees, out, false);
                continue;
            }
            // If we got this far, the child is structurally normal
            out.push(child);
        }
        else {
            out.push(child);
        }
    }
    return out;
};
var assembleNodeMemoryChildren = function (node, subtree) {
    if (subtree) {
        return [subtree];
    }
    if (node.__memory.placeholder) {
        return [];
    }
    // To avoid creating garbage, only allow allocations here if we actually need virtual children.
    if (!node.children || !node.children.some(needsVirtualChildren)) {
        return;
    }
    return reduceNodeMemoryChildren(node.children, [], true);
};
var expandNode = function (node, parent) {
    if (!node || typeof node !== 'object' || !node.__memory) {
        return;
    }
    var children = node.children;
    // Special case if our current original is the wrapper of a subcomponent.
    var subtree = node.__memory.subcomponent && node.__memory.subcomponent.bytecode.template;
    var assembled = assembleNodeMemoryChildren(node, subtree);
    // Don't just overwrite, since node.__memory.children may've been set to vanity 'content'
    if (assembled) {
        node.__memory.children = assembled;
    }
    if (node.__memory.children) {
        children = node.__memory.children;
    }
    /**
     * When we compute layout, we have the following chicken/egg problem:
     * 1. Nodes which are "auto"-sized consume their children's size to calculate their own size.
     * 2. Nodes with a SIZE_PROPORTIONAL depend on parent absolute size to compute their target size. (DEPRECATED)
     * 3. Nodes with an "auto"-sized parent consume their parent's bounds to calculate a translation offset.
     *
     * Thus, we perform the layout steps in the following order:
     * 1. Compute the current node's layout.
     *   1.a. If the current node is "auto"-sized, compute the size of the children. For each child,
     *        we compute its bounding rect using its *local* transform (not using its parent size).
     *        This is sufficient to obtain a bounding box in local coordinate space with respect to
     *        an unknown container. We then use all of the rects to determine the outermost bbox,
     *        which in turn is used to determine the current node's size.
     *   1.b. If the current node is numerically sized, use that size.
     * 2. Expand all children of the current node. By now, the parent should have a numeric size.
     *   2.a. For SIZE_PROPORTIONAL nodes, compute the layout as proportion of the parent size.
     *   2.b. For other nodes, compute its local size.
     *   2.c. If the parent was "auto"-sized, it should have its bounds precalculated from the
     *        previous pass. When this is the case, use the bounds to calculate an offset value
     *        by which translation will be offset, aligning all children to be perfectly flush
     *        with their container, no matter what size it is.
     */
    computeAndApplyLayout(node, parent);
    if (children) {
        for (var j = 0; j < children.length; j++) {
            // Special case: The subtree of the subcomponent doesn't need to be re-expanded.
            if (children[j] !== subtree) {
                expandNode(children[j], node);
            }
        }
    }
};
var computeAndApplyLayout = function (node, parent) {
    // Don't assume the node has/needs a layout, for example, control-flow injectees
    if (node.layout) {
        node.layout.computed = HaikuElement_1.default.computeLayout(node, parent);
    }
};
var hydrateNode = function (node, parent, component, context, host, scope, options, doConnectInstanceToNode) {
    if (options === void 0) { options = {}; }
    // Nothing to expand if the node happens to be text or unexpected type
    if (!node || typeof node !== 'object') {
        return;
    }
    // Hydrate a HaikuElement representation of all nodes in the tree.
    // The instance is cached as node.__memory.element for performance purposes.
    HaikuElement_1.default.findOrCreateByNode(node);
    component.cacheNodeWithSelectorKey(node);
    // Platform-specific renderers may depend on access to the parent.
    node.__memory.parent = parent;
    // So renderers can detect when different layout behavior is needed.
    node.__memory.scope = scope || 'div';
    // Give it a pointer back to the host context; used by HaikuElement
    node.__memory.context = context;
    Layout3D_1.default.initializeNodeAttributes(node, doConnectInstanceToNode);
    // Give instances a pointer to their node and vice versa
    if (doConnectInstanceToNode) {
        node.__memory.instance = component;
        // In the case that the node represents the root of an instance, treat the instance as the element;
        // connect their references and override the equivalent action in findOrCreateByNode.
        HaikuElement_1.default.connectNodeWithElement(node, node.__memory.instance);
    }
    // If the element name is missing it should still be safe to hydrate the children
    if (typeof node.elementName === STRING_TYPE || !node.elementName) {
        if (node.children) {
            for (var i = 0; i < node.children.length; i++) {
                hydrateNode(node.children[i], // node
                node, // parent
                component, // instance (component)
                context, host, SCOPE_STRATA[node.elementName] || scope, // scope
                options, false);
            }
        }
        return;
    }
    if (isBytecode(node.elementName)) {
        // Example structure showing how nodes and instances are related:
        // <div root> instance id=1
        //   <div>
        //     <div>
        //       <div wrap> subcomponent (instance id=2)
        //         <div root> instance id=2
        //           ...
        if (!node.__memory.subcomponent) {
            var config = Config_1.default.buildChildSafeConfig(__assign({}, context.config, options));
            // Note: .render and thus .hydrateNode are called by the constructor,
            // automatically connecting the root node to itself (see stanza above).
            node.__memory.subcomponent = new HaikuComponent(node.elementName, context, // context
            component, __assign({ loop: true }, config), node);
            // Very important, as the guests collection is used in rendering/patching
            component.registerGuest(node.__memory.subcomponent);
        }
        else {
            // Reassigning is necessary since these objects may have changed between
            // renders in the editing environment
            node.__memory.subcomponent.context = context; // context
            node.__memory.subcomponent.host = component; // host
            node.__memory.subcomponent.container = node; // container
            // Very important, as the guests collection is used in rendering/patching
            component.registerGuest(node.__memory.subcomponent);
            // Don't re-start any nested timelines that have been explicitly paused
            if (!node.__memory.subcomponent.getDefaultTimeline().isPaused()) {
                node.__memory.subcomponent.startTimeline(DEFAULT_TIMELINE_NAME);
            }
        }
        return;
    }
    // In case we got a __reference node or other unknown
    console.warn('[haiku core] cannot hydrate node');
};
var computeAndApplyPresetSizing = function (element, container, mode) {
    var elementWidth = element.layout.sizeAbsolute.x;
    var elementHeight = element.layout.sizeAbsolute.y;
    // Some browsers does not work correctly with matrix3d transforms on SVGs
    // with resulting subpixel rendering, so let's round up the size to avoid
    // browser problems
    var containerWidth = Math.ceil(container.layout.computed.size.x);
    var containerHeight = Math.ceil(container.layout.computed.size.y);
    // I.e., the amount by which we'd have to multiply the element's scale to make it
    // exactly the same size as its container (without going above it)
    var scaleDiffX = containerWidth / elementWidth;
    var scaleDiffY = containerHeight / elementHeight;
    // This makes sure that the sizing occurs with respect to a correct and consistent origin point,
    // but only if the user didn't happen to explicitly set this value (we allow their override).
    if (!element.attributes.style['transform-origin']) {
        element.attributes.style['transform-origin'] = '0% 0% 0px';
    }
    // IMPORTANT: If any value has been changed on the element, you must set this to true.
    // Otherwise the changed object won't go into the deltas dictionary, and the element won't update.
    var changed = false;
    switch (mode) {
        // Make the base element its default scale, which is just a multiplier of one. This is the default.
        case 'normal':
            if (element.layout.scale.x !== 1.0 || element.layout.scale.y !== 1.0) {
                changed = true;
                element.layout.scale.x = element.layout.scale.y = 1.0;
            }
            break;
        // Stretch the element to fit the container on both x and y dimensions (distortion allowed)
        case 'stretch':
            if (scaleDiffX !== element.layout.scale.x) {
                changed = true;
                element.layout.scale.x = scaleDiffX;
            }
            if (scaleDiffY !== element.layout.scale.y) {
                changed = true;
                element.layout.scale.y = scaleDiffY;
            }
            break;
        // CONTAIN algorithm
        // see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size?v=example
        // A keyword that scales the image as large as possible and maintains image aspect ratio
        // (image doesn't get squished). Image is letterboxed within the container.
        // When the image and container have different dimensions, the empty areas (either top/bottom of left/right)
        // are filled with the background-color.
        case 'contain':
        case true: // (Legacy.)
            var containScaleToUse = null;
            // We're looking for the larger of the two scales that still allows both dimensions to fit in the box
            // The rounding is necessary to avoid precision issues, where we end up comparing e.g. 2.0000000000001 to 2
            if (~~(scaleDiffX * elementWidth) <= containerWidth &&
                ~~(scaleDiffX * elementHeight) <= containerHeight) {
                containScaleToUse = scaleDiffX;
            }
            if (~~(scaleDiffY * elementWidth) <= containerWidth &&
                ~~(scaleDiffY * elementHeight) <= containerHeight) {
                if (containScaleToUse === null) {
                    containScaleToUse = scaleDiffY;
                }
                else {
                    if (scaleDiffY >= containScaleToUse) {
                        containScaleToUse = scaleDiffY;
                    }
                }
            }
            if (element.layout.scale.x !== containScaleToUse) {
                changed = true;
                element.layout.scale.x = containScaleToUse;
            }
            if (element.layout.scale.y !== containScaleToUse) {
                changed = true;
                element.layout.scale.y = containScaleToUse;
            }
            // Offset the translation so that the element remains centered within the letterboxing
            var containTranslationOffsetX = -(containScaleToUse * elementWidth - containerWidth) / 2;
            var containTranslationOffsetY = -(containScaleToUse * elementHeight - containerHeight) / 2;
            if (element.layout.translation.x !== containTranslationOffsetX) {
                changed = true;
                element.layout.translation.x = containTranslationOffsetX;
            }
            if (element.layout.translation.y !== containTranslationOffsetY) {
                changed = true;
                element.layout.translation.y = containTranslationOffsetY;
            }
            break;
        // COVER algorithm (inverse of CONTAIN)
        // see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size?v=example
        // A keyword that is the inverse of contain. Scales the image as large as possible and maintains
        // image aspect ratio (image doesn't get squished). The image "covers" the entire width or height
        // of the container. When the image and container have different dimensions, the image is clipped
        // either left/right or top/bottom.
        case 'cover':
            var coverScaleToUse = null;
            // We're looking for the smaller of two scales that ensures the entire box is covered.
            // The rounding is necessary to avoid precision issues, where we end up comparing e.g. 2.0000000000001 to 2
            if (~~(scaleDiffX * elementHeight) >= containerHeight) {
                coverScaleToUse = scaleDiffX;
            }
            else if (~~(scaleDiffY * elementWidth) >= containerWidth) {
                coverScaleToUse = scaleDiffY;
            }
            else {
                coverScaleToUse = Math.max(scaleDiffX, scaleDiffY);
            }
            if (element.layout.scale.x !== coverScaleToUse) {
                changed = true;
                element.layout.scale.x = coverScaleToUse;
            }
            if (element.layout.scale.y !== coverScaleToUse) {
                changed = true;
                element.layout.scale.y = coverScaleToUse;
            }
            // Offset the translation so that the element remains centered despite clipping
            var coverTranslationOffsetX = -(coverScaleToUse * elementWidth - containerWidth) / 2;
            var coverTranslationOffsetY = -(coverScaleToUse * elementHeight - containerHeight) / 2;
            if (element.layout.translation.x !== coverTranslationOffsetX) {
                changed = true;
                element.layout.translation.x = coverTranslationOffsetX;
            }
            if (element.layout.translation.y !== coverTranslationOffsetY) {
                changed = true;
                element.layout.translation.y = coverTranslationOffsetY;
            }
            break;
    }
    return changed;
};
exports.clone = function (value, binding) {
    if (!value) {
        return value;
    }
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'number') {
        return value;
    }
    if (typeof value === 'string') {
        return value;
    }
    if (typeof value === 'function') {
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return value.call.apply(value, [binding].concat(args));
        };
        // Core decorates injectee functions with metadata properties
        for (var key in value) {
            if (value.hasOwnProperty(key)) {
                fn[key] = exports.clone(value[key], binding);
            }
        }
        fn.__rfo = functionToRFO_1.default(value).__function;
        return fn;
    }
    if (Array.isArray(value)) {
        return value.map(function (el) { return exports.clone(el, binding); });
    }
    // Don't try to clone anything other than plain objects
    if (typeof value === 'object' && value.constructor === Object) {
        var out = {};
        for (var key in value) {
            if (!value.hasOwnProperty(key) || key.slice(0, 2) === '__') {
                continue;
            }
            // If it looks like guest bytecode, don't clone it since
            // (a) we're passing down *our* function binding, which will break event handling and
            // (b) each HaikuComponent#constructor calls clone() on its own anyway
            if (key === 'elementName' && typeof value[key] !== 'string') {
                out[key] = value[key];
            }
            else {
                out[key] = exports.clone(value[key], binding);
            }
        }
        return out;
    }
    return value;
};
var setStyle = function (subkey, element, value) {
    element.attributes.style[subkey] = value;
};
var setAttribute = function (key, element, value) {
    var final = exports.ATTRS_CAMEL_TO_HYPH[key] || key;
    element.attributes[final] = value;
};
var isNumeric = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
};
var isInteger = function (x) {
    return x % 1 === 0;
};
var REACT_MATCHING_OPTIONS = {
    name: 'type',
    attributes: 'props',
};
var HAIKU_MATCHING_OPTIONS = {
    name: 'elementName',
    attributes: 'attributes',
};
var querySelectSubtree = function (surrogate, value) {
    // First try the Haiku format
    if (HaikuNode_1.cssMatchOne(surrogate, value, HAIKU_MATCHING_OPTIONS)) {
        return surrogate;
    }
    // If no match yet, try the React format (TODO: Does this belong here?)
    if (HaikuNode_1.cssMatchOne(surrogate, value, REACT_MATCHING_OPTIONS)) {
        return surrogate;
    }
    // Visit the descendants (if any) and see if we have a match there
    var children = (surrogate.children || // Haiku's format
        (surrogate.props && surrogate.props.children) // React's format
    );
    // If no children, we definitely don't have a match in this subtree
    if (!children) {
        return null;
    }
    // Check for arrays first since arrays pass the typeof object check
    if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
            var found = querySelectSubtree(children[i], value);
            // First time a match is found, break the loop and return it
            if (found) {
                return found;
            }
        }
    }
    // React may store 'children' as a single object
    if (typeof children === 'object') {
        return querySelectSubtree(children, value);
    }
};
var querySelectSurrogates = function (surrogates, value) {
    if (Array.isArray(surrogates)) {
        // Return the first match we locate in the collection
        return surrogates.map(function (surrogate) { return querySelectSurrogates(surrogate, value); })[0];
    }
    if (surrogates && typeof surrogates === 'object') {
        return querySelectSubtree(surrogates, value);
    }
};
var selectSurrogate = function (surrogates, value) {
    // If the placeholder value is intended as an array index
    if (Array.isArray(surrogates) && isNumeric(value) && isInteger(value)) {
        if (surrogates[value]) {
            return surrogates[value];
        }
    }
    // If the placeholder value is intended as a key
    if (surrogates && typeof surrogates === 'object' && typeof value === 'string') {
        if (surrogates[value]) {
            return surrogates[value];
        }
    }
    return querySelectSurrogates(surrogates, value + '');
};
var getCanonicalPlaybackValue = function (value) {
    if (typeof value !== 'object') {
        return {
            Default: value,
        };
    }
    return value;
};
/**
 * 'Vanities' are functions that provide special handling for applied properties.
 * So for example, if a component wants to apply 'foo.bar'=3 to a <div> in its template,
 * the renderer will look in the vanities dictionary to see if there is a
 * vanity 'foo.bar' available, and if so, pass the value 3 into that function.
 * The function, in turn, knows how to apply that value to the virtual element passed into
 * it. In the future these will be defined by components themselves as inputs; for now,
 * we are keeping a whitelist of possible vanity handlers which the renderer directly
 * loads and calls.
 */
exports.getVanity = function (elementName, propertyName) {
    if (elementName) {
        if (exports.VANITIES[elementName] && exports.VANITIES[elementName][propertyName]) {
            return exports.VANITIES[elementName][propertyName];
        }
    }
    return exports.VANITIES['*'][propertyName];
};
/**
 * Ensures layout before applying a layout vanity.
 */
var ensureLayout = function (node) {
    if (!node.layout) {
        Layout3D_1.default.initializeNodeLayout(node);
    }
};
exports.LAYOUT_3D_VANITIES = {
    // Layout has a couple of special values that relate to display
    // but not to position:
    shown: function (_, element, value) {
        ensureLayout(element);
        element.layout.shown = value;
    },
    // Opacity needs to have its opacity *layout* property set
    // as opposed to its element attribute so the renderer can make a decision about
    // where to put it based on the rendering medium's rules
    opacity: function (_, element, value) {
        ensureLayout(element);
        element.layout.opacity = value;
    },
    // If you really want to set what we call 'position' then
    // we do so on the element's attributes; this is mainly to
    // enable the x/y positioning system for SVG elements.
    'position.x': function (name, element, value) {
        ensureLayout(element);
        element.attributes.x = value;
    },
    'position.y': function (name, element, value) {
        ensureLayout(element);
        element.attributes.y = value;
    },
    // Everything that follows is a standard 3-coord component
    // relating to the element's position in space
    'rotation.x': function (_, element, value) {
        ensureLayout(element);
        element.layout.rotation.x = value;
    },
    'rotation.y': function (_, element, value) {
        ensureLayout(element);
        element.layout.rotation.y = value;
    },
    'rotation.z': function (_, element, value) {
        ensureLayout(element);
        element.layout.rotation.z = value;
    },
    'offset.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.offset.x = value;
    },
    'offset.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.offset.y = value;
    },
    'offset.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.offset.z = value;
    },
    'origin.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.origin.x = value;
    },
    'origin.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.origin.y = value;
    },
    'origin.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.origin.z = value;
    },
    'scale.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.scale.x = value;
    },
    'scale.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.scale.y = value;
    },
    'scale.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.scale.z = value;
    },
    'sizeAbsolute.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeAbsolute.x = value;
    },
    'sizeAbsolute.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeAbsolute.y = value;
    },
    'sizeAbsolute.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeAbsolute.z = value;
    },
    'sizeDifferential.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeDifferential.x = value;
    },
    'sizeDifferential.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeDifferential.y = value;
    },
    'sizeDifferential.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeDifferential.z = value;
    },
    'sizeMode.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeMode.x = value;
    },
    'sizeMode.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeMode.y = value;
    },
    'sizeMode.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeMode.z = value;
    },
    'sizeProportional.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeProportional.x = value;
    },
    'sizeProportional.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeProportional.y = value;
    },
    'sizeProportional.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.sizeProportional.z = value;
    },
    'shear.xy': function (name, element, value) {
        ensureLayout(element);
        element.layout.shear.xy = value;
    },
    'shear.xz': function (name, element, value) {
        ensureLayout(element);
        element.layout.shear.xz = value;
    },
    'shear.yz': function (name, element, value) {
        ensureLayout(element);
        element.layout.shear.yz = value;
    },
    'translation.x': function (name, element, value) {
        ensureLayout(element);
        element.layout.translation.x = value;
    },
    'translation.y': function (name, element, value) {
        ensureLayout(element);
        element.layout.translation.y = value;
    },
    'translation.z': function (name, element, value) {
        ensureLayout(element);
        element.layout.translation.z = value;
    },
};
exports.VANITIES = {
    '*': __assign({}, exports.LAYOUT_3D_VANITIES, { 
        // CSS style properties that need special handling
        'style.WebkitTapHighlightColor': function (_, element, value) {
            element.attributes.style.webkitTapHighlightColor = value;
        }, 
        // Text and other inner-content related vanities
        content: function (name, element, value, context, timeline, receiver, sender) {
            element.__memory.children = [value];
            // If we don't do this, then content changes resulting from setState calls
            // don't have the effect of flushing the content, and the rendered text doesn't change.
            // DEMO: bind-numeric-state-to-text
            // TODO: What is the best way to make this less expensive (while still functional)?
            sender.patches.push(element);
        }, 
        // Playback-related vanities that involve controlling timeline or clock time
        playback: function (name, element, value, context, timeline, receiver, sender) {
            var canonicalValue = getCanonicalPlaybackValue(value);
            for (var timelineName in canonicalValue) {
                var timelineInstance = receiver && receiver.getTimeline(timelineName);
                if (timelineInstance) {
                    timelineInstance.setPlaybackStatus(canonicalValue[timelineName]);
                }
            }
        }, 
        // Control-flow vanities that alter the output structure of the component
        'controlFlow.placeholder': function (name, element, value, context, timeline, receiver, sender) {
            // For MVP's sake, structural behaviors not rendered during hot editing.
            if (sender.config.hotEditingMode) {
                return;
            }
            if (value === null || value === undefined) {
                return;
            }
            if (typeof value !== 'number' && typeof value !== 'string') {
                return;
            }
            var surrogates;
            // Surrogates can be passed in as:
            //   - React children (an array)
            //   - A React subtree (we'll use query selectors to match)
            //   - A Haiku subtree (we'll use query selectors to match)
            //   - Key/value pairs
            if (context.config.children) {
                surrogates = context.config.children;
                if (!Array.isArray(surrogates)) {
                    surrogates = [surrogates];
                }
            }
            else if (context.config.placeholder) {
                surrogates = context.config.placeholder;
            }
            if (!surrogates) {
                return;
            }
            var surrogate = selectSurrogate(surrogates, value);
            if (surrogate === null || surrogate === undefined) {
                return;
            }
            if (!element.__memory.placeholder) {
                element.__memory.placeholder = {};
            }
            element.__memory.placeholder.value = value;
            // If we are running via a framework adapter, allow that framework to provide its own placeholder mechanism.
            // This is necessary e.g. in React where their element format needs to be converted into our 'mana' format
            if (context.config.vanities['controlFlow.placeholder']) {
                context.config.vanities['controlFlow.placeholder'](element, surrogate, value, context, timeline, receiver, sender);
            }
            else {
                element.__memory.placeholder.surrogate = surrogate;
            }
        }, 'controlFlow.repeat': function (name, element, value, context, timeline, receiver, sender) {
            var instructions;
            if (Array.isArray(value)) {
                instructions = value;
            }
            else if (isNumeric(value)) {
                var arr = [];
                for (var i = 0; i < value; i++) {
                    arr.push({}); // Empty repeat payload spec
                }
                instructions = arr;
            }
            else {
                return;
            }
            if (element.__memory.repeatee) {
                // Don't repeat the repeatee of an existing repeater
                if (element.__memory.repeatee.index > 0) {
                    return;
                }
            }
            if (element.__memory.repeater) {
                if (element.__memory.repeater.changed) {
                    element.__memory.repeater.changed = false;
                }
                else {
                    // Save CPU by avoiding recomputing a repeat when we've already done so.
                    // Although upstream HaikuComponent#applyLocalBehaviors does do diff comparisons,
                    // it intentionally skips this comparison for complex properties i.e. arrays
                    // and objects due to the intractability of smartly comparing for all cases.
                    // We do a comparison that is fairly sensible in the repeat-exclusive case.
                    if (isSameRepeatBehavior(element.__memory.repeater.instructions, instructions)) {
                        return;
                    }
                }
            }
            if (!element.__memory.repeater) {
                element.__memory.repeater = {};
            }
            element.__memory.repeater.instructions = instructions;
            // Structural behaviors are not rendered during hot editing.
            if (sender.config.hotEditingMode) {
                // If we got at least one instruction, render that by default into the repeater
                if (instructions.length > 0) {
                    element.__memory.repeatee = {
                        instructions: instructions,
                        index: 0,
                        payload: instructions[0],
                        source: element,
                    };
                    applyPayloadToNode(element, instructions[0], sender, timeline);
                    sender.patches.push(element);
                    expandNode(element, element.__memory.parent);
                }
                return;
            }
            if (!element.__memory.repeater.repeatees) {
                element.__memory.repeater.repeatees = [];
            }
            else {
                // If the instructions have decreased on this run, remove the excess repeatees
                element.__memory.repeater.repeatees.splice(instructions.length);
            }
            instructions.forEach(function (payload, index) {
                var repeatee = (index === 0)
                    ? element // The first element should be the source element
                    : element.__memory.repeater.repeatees[index] || exports.clone(element, sender);
                // We have to initialize the element's component instance, etc.
                hydrateNode(repeatee, element.__memory.parent, // parent
                sender, // component
                sender.context, // context
                sender, // host
                element.__memory.scope, // scope (use same scope as source node)
                sender.config, // options
                false);
                repeatee.__memory.repeatee = {
                    index: index,
                    instructions: instructions,
                    payload: payload,
                    source: element,
                };
                applyPayloadToNode(repeatee, payload, sender, timeline);
                element.__memory.repeater.repeatees[index] = repeatee;
            });
            sender.patches.push(element);
            expandNode(element, element.__memory.parent);
        }, 'controlFlow.if': function (name, element, value, context, timeline, receiver, sender) {
            // For MVP's sake, structural behaviors not rendered during hot editing.
            if (sender.config.hotEditingMode) {
                return;
            }
            // Assume our if-answer is only false if we got an explicit false value
            var answer = value !== false;
            if (element.__memory.if) {
                // Save CPU by avoiding recomputing an if when we've already done so.
                if (isSameIfBehavior(element.__memory.if.answer, answer)) {
                    return;
                }
            }
            element.__memory.if = {
                answer: answer,
            };
            // Ensure that a change in repeat will trigger the necessary re-repeat
            if (element.__memory.repeater) {
                element.__memory.repeater.changed = true;
            }
            sender.markForFullFlush();
        } }),
};
var applyPayloadToNode = function (node, payload, sender, timeline) {
    // Apply the repeat payload to the element as if it were a normal timeline output
    for (var propertyName in payload) {
        // Control-flow occurs after presentational behaviors, meaning we are overriding
        // whatever may have been set on the source element instance.
        sender.applyPropertyToNode(node, // matchingElement
        propertyName, payload[propertyName], // finalValue
        timeline);
    }
};
var isSameIfBehavior = function (prev, next) {
    return prev === next;
};
var isSameRepeatBehavior = function (prevs, nexts) {
    if (prevs === nexts) {
        return true;
    }
    if (prevs.length !== nexts.length) {
        return false;
    }
    var answer = true;
    for (var i = 0; i < prevs.length; i++) {
        if (!answer) {
            break;
        }
        var prev = prevs[i];
        var next = nexts[i];
        if (prev === next) {
            continue;
        }
        for (var key in next) {
            if (next[key] !== prev[key]) {
                answer = false;
                break;
            }
        }
    }
    return answer;
};
var findRespectiveRepeatees = function (target) {
    var repeatees = [];
    // Required to fix a race condition that can occur during copy+paste in Haiku.app
    if (!target.__memory) {
        return repeatees;
    }
    // The host repeatee of the given target node, if the target is a repeater's descendant
    var host;
    if (target.__memory.repeatee) {
        host = target;
    }
    else {
        // Note that we do not ascend beyond the nearest host component instance
        HaikuNode_1.ascend(target, function (node) {
            if (node.__memory.repeatee) {
                host = node;
            }
        });
    }
    // If we've found a host repeatee, the target is a descendant of a repeater,
    // and we need to find its respective node within each repeatee.
    if (host) {
        var repeater = host.__memory.repeatee.source;
        if (repeater.__memory.repeater.repeatees) {
            repeater.__memory.repeater.repeatees.forEach(function (repeatee) {
                HaikuNode_1.visit(repeatee, function (candidate) {
                    if (areNodesRespective(target, candidate)) {
                        repeatees.push(candidate);
                    }
                });
            });
        }
    }
    return repeatees;
};
var areNodesRespective = function (n1, n2) {
    if (n1 === n2) {
        return true;
    }
    // We assume that all nodes within the tree of a component have unique haiku-ids, and that
    // these haiku-ids are not directly modified within repeater groups
    if (
    // If the haiku-id attribute is empty, assume the comparison isn't valid
    n1.attributes[HAIKU_ID_ATTRIBUTE] &&
        n1.attributes[HAIKU_ID_ATTRIBUTE] === n2.attributes[HAIKU_ID_ATTRIBUTE]) {
        return true;
    }
    return false;
};
exports.getFallback = function (elementName, propertyName) {
    if (elementName) {
        if (LAYOUT_COORDINATE_SYSTEM_FALLBACKS[elementName] &&
            LAYOUT_COORDINATE_SYSTEM_FALLBACKS[elementName][propertyName] !== undefined) {
            return LAYOUT_COORDINATE_SYSTEM_FALLBACKS[elementName][propertyName];
        }
        if (exports.FALLBACKS[elementName] && exports.FALLBACKS[elementName][propertyName] !== undefined) {
            return exports.FALLBACKS[elementName][propertyName];
        }
    }
    return exports.FALLBACKS['*'][propertyName];
};
var LAYOUT_COORDINATE_SYSTEM_FALLBACKS = {
    svg: {
        'origin.x': 0.5,
        'origin.y': 0.5,
        'origin.z': 0.5,
    },
};
var LAYOUT_DEFAULTS = Layout3D_1.default.createLayoutSpec();
exports.FALLBACKS = {
    '*': {
        shown: LAYOUT_DEFAULTS.shown,
        opacity: LAYOUT_DEFAULTS.opacity,
        content: '',
        'offset.x': LAYOUT_DEFAULTS.offset.x,
        'offset.y': LAYOUT_DEFAULTS.offset.y,
        'offset.z': LAYOUT_DEFAULTS.offset.z,
        'origin.x': LAYOUT_DEFAULTS.origin.x,
        'origin.y': LAYOUT_DEFAULTS.origin.y,
        'origin.z': LAYOUT_DEFAULTS.origin.z,
        'translation.x': LAYOUT_DEFAULTS.translation.x,
        'translation.y': LAYOUT_DEFAULTS.translation.y,
        'translation.z': LAYOUT_DEFAULTS.translation.z,
        'rotation.x': LAYOUT_DEFAULTS.rotation.x,
        'rotation.y': LAYOUT_DEFAULTS.rotation.y,
        'rotation.z': LAYOUT_DEFAULTS.rotation.z,
        'scale.x': LAYOUT_DEFAULTS.scale.x,
        'scale.y': LAYOUT_DEFAULTS.scale.y,
        'scale.z': LAYOUT_DEFAULTS.scale.z,
        'shear.xy': LAYOUT_DEFAULTS.shear.xy,
        'shear.xz': LAYOUT_DEFAULTS.shear.xz,
        'shear.yz': LAYOUT_DEFAULTS.shear.yz,
        'sizeAbsolute.x': LAYOUT_DEFAULTS.sizeAbsolute.x,
        'sizeAbsolute.y': LAYOUT_DEFAULTS.sizeAbsolute.y,
        'sizeAbsolute.z': LAYOUT_DEFAULTS.sizeAbsolute.z,
        'sizeProportional.x': LAYOUT_DEFAULTS.sizeProportional.x,
        'sizeProportional.y': LAYOUT_DEFAULTS.sizeProportional.y,
        'sizeProportional.z': LAYOUT_DEFAULTS.sizeProportional.z,
        'sizeDifferential.x': LAYOUT_DEFAULTS.sizeDifferential.x,
        'sizeDifferential.y': LAYOUT_DEFAULTS.sizeDifferential.y,
        'sizeDifferential.z': LAYOUT_DEFAULTS.sizeDifferential.z,
        'sizeMode.x': LAYOUT_DEFAULTS.sizeMode.x,
        'sizeMode.y': LAYOUT_DEFAULTS.sizeMode.y,
        'sizeMode.z': LAYOUT_DEFAULTS.sizeMode.z,
        'style.overflowX': 'hidden',
        'style.overflowY': 'hidden',
        'style.zIndex': 1,
        'style.WebkitTapHighlightColor': 'rgba(0,0,0,0)',
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        r: 0,
        cx: 0,
        cy: 0,
        rx: 0,
        ry: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        playback: "loop" /* LOOP */,
        'controlFlow.repeat': null,
        'controlFlow.placeholder': null,
    },
};
exports.LAYOUT_3D_SCHEMA = {
    shown: 'boolean',
    opacity: 'number',
    'offset.x': 'number',
    'offset.y': 'number',
    'offset.z': 'number',
    'origin.x': 'number',
    'origin.y': 'number',
    'origin.z': 'number',
    'translation.x': 'number',
    'translation.y': 'number',
    'translation.z': 'number',
    'rotation.x': 'number',
    'rotation.y': 'number',
    'rotation.z': 'number',
    'scale.x': 'number',
    'scale.y': 'number',
    'scale.z': 'number',
    'shear.xy': 'number',
    'shear.xz': 'number',
    'shear.yz': 'number',
    'sizeAbsolute.x': 'number',
    'sizeAbsolute.y': 'number',
    'sizeAbsolute.z': 'number',
    'sizeProportional.x': 'number',
    'sizeProportional.y': 'number',
    'sizeProportional.z': 'number',
    'sizeDifferential.x': 'number',
    'sizeDifferential.y': 'number',
    'sizeDifferential.z': 'number',
    'sizeMode.x': 'number',
    'sizeMode.y': 'number',
    'sizeMode.z': 'number',
};
exports.ATTRS_CAMEL_TO_HYPH = {
    accentHeight: 'accent-height',
    alignmentBaseline: 'alignment-baseline',
    arabicForm: 'arabic-form',
    baselineShift: 'baseline-shift',
    capHeight: 'cap-height',
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    dominantBaseline: 'dominant-baseline',
    enableBackground: 'enable-background',
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    imageRendering: 'image-rendering',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    panose1: 'panose-1',
    paintOrder: 'paint-order',
    pointerEvents: 'pointer-events',
    renderingIntent: 'rendering-intent',
    shapeRendering: 'shape-rendering',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    vectorEffect: 'vector-effect',
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    xHeight: 'x-height',
};
var PositionSchema = {
    x: 'number',
    y: 'number',
    z: 'number',
};
exports.ATTRS_HYPH_TO_CAMEL = {};
for (var camel in exports.ATTRS_CAMEL_TO_HYPH) {
    exports.ATTRS_HYPH_TO_CAMEL[exports.ATTRS_CAMEL_TO_HYPH[camel]] = camel;
}
INJECTABLES.$element = {
    schema: {
        offset: PositionSchema,
        attributes: {},
        tagName: 'string',
        matrix: [],
        opacity: 'number',
        origin: PositionSchema,
        rotation: PositionSchema,
        scale: PositionSchema,
        shown: 'boolean',
        size: { x: 'number', y: 'number' },
        sizeAbsolute: PositionSchema,
        sizeProportional: PositionSchema,
        translation: PositionSchema,
    },
    summon: function (injectees, component, node) {
        injectees.$element = HaikuElement_1.default.findOrCreateByNode(node);
    },
};
INJECTABLES.$window = {
    schema: {},
    summon: function (injectees) {
        injectees.$window = (typeof window !== 'undefined') ? window : {};
    },
};
INJECTABLES.$mount = {
    schema: {},
    summon: function (injectees, component) {
        injectees.$mount = component.context.renderer.mount;
    },
};
INJECTABLES.$timeline = {
    schema: {},
    summon: function (injectees, component, node, timelineName) {
        injectees.$timeline = component.getTimeline(timelineName);
    },
};
INJECTABLES.$clock = {
    schema: {
        destroy: 'function',
        getExplicitTime: 'function',
        getFrameDuration: 'function',
        getTime: 'function',
        setTime: 'function',
        isRunning: 'function',
        run: 'function',
        start: 'function',
        assignOptions: 'function',
    },
    summon: function (injectees, component) {
        injectees.$clock = component.getClock();
    },
};
INJECTABLES.$core = {
    schema: {
        options: Config_1.DEFAULTS,
        timeline: INJECTABLES.$timeline.schema,
        clock: INJECTABLES.$clock.schema,
    },
    summon: function (injectees, component, node, timelineName) {
        injectees.$core = {
            component: component,
            context: component.context,
            options: component.config,
            timeline: component.getTimeline(timelineName),
            clock: component.getClock(),
        };
    },
};
INJECTABLES.$context = {
    schema: {},
    summon: function (injectees, component) {
        injectees.$context = component.context;
    },
};
INJECTABLES.$component = {
    schema: INJECTABLES.$element.schema,
    summon: function (injectees, component) {
        injectees.$component = component;
    },
};
INJECTABLES.$host = {
    schema: {},
    summon: function (injectees, component) {
        injectees.$host = component.host;
    },
};
INJECTABLES.$top = {
    schema: {},
    summon: function (injectees, component) {
        injectees.$host = component.top;
    },
};
INJECTABLES.$state = {
    schema: {},
    summon: function (injectees, component) {
        injectees.$state = component.state;
    },
};
INJECTABLES.$parent = {
    schema: INJECTABLES.$element.schema,
    summon: function (injectees, component, node) {
        injectees.$parent = HaikuElement_1.default.findOrCreateByNode(node).parent;
    },
};
INJECTABLES.$container = {
    schema: INJECTABLES.$element.schema,
    summon: function (injectees, component, node) {
        var element = HaikuElement_1.default.findOrCreateByNode(node);
        injectees.$container = element.owner;
    },
};
INJECTABLES.$children = {
    schema: INJECTABLES.$element.schema.children,
    summon: function (injectees, component, node) {
        injectees.$children = HaikuElement_1.default.findOrCreateByNode(node).children;
    },
};
INJECTABLES.$tree = {
    schema: {
        parent: INJECTABLES.$element.schema,
        chidren: INJECTABLES.$element.schema.children,
        component: INJECTABLES.$element.schema,
        root: INJECTABLES.$element.schema,
        element: INJECTABLES.$element.schema,
    },
    summon: function (injectees, component, node) {
        var element = HaikuElement_1.default.findOrCreateByNode(node);
        injectees.$tree = {
            element: element,
            component: component,
            parent: element.parent,
            children: element.children,
            root: element.owner,
        };
    },
};
INJECTABLES.$user = {
    schema: {
        mouse: {
            x: 'number',
            y: 'number',
            down: 'boolean',
            buttons: [],
        },
        mouches: [],
        keys: {},
        touches: [],
        pan: {
            x: 'number',
            y: 'number',
        },
    },
    summon: function (injectees, component, node) {
        if (component.isLiveMode()) {
            injectees.$user = component.context.getGlobalUserState();
            // If we're inside another component, produce mouse coords in terms
            // of our own coordinate space
            if (component.host) {
                Object.assign(injectees.$user.mouse, component.transformContextPointToLocalPoint(Object.assign({}, injectees.$user.mouse)));
            }
        }
        else {
            injectees.$user = {
                mouse: {
                    x: 1,
                    y: 1,
                    down: 0,
                    buttons: [0, 0, 0],
                },
                pan: {
                    x: 0,
                    y: 0,
                },
                keys: {},
                touches: [],
                mouches: [],
            };
        }
    },
};
var getRepeatHostNode = function (node) {
    if (!node) {
        return;
    }
    if (node.__memory.repeatee) {
        return node;
    }
    return getRepeatHostNode(node.__memory && node.__memory.parent);
};
var getIfHostNode = function (node) {
    if (!node) {
        return;
    }
    if (node.__memory.if) {
        return node;
    }
    return getIfHostNode(node.__memory && node.__memory.parent);
};
INJECTABLES.$flow = {
    schema: {},
    summon: function (injectees, component, node) {
        if (!injectees.$flow) {
            injectees.$flow = {};
        }
        var repeatNode = getRepeatHostNode(node);
        injectees.$flow.repeat = (repeatNode && repeatNode.__memory.repeatee) || {
            instructions: [],
            payload: {},
            source: repeatNode,
            index: 0,
        };
        var ifNode = getIfHostNode(node);
        injectees.$flow.if = (ifNode && ifNode.__memory.if) || {
            answer: null,
        };
        injectees.$flow.placeholder = node.__memory.placeholder || {
            value: null,
            surrogate: null,
        };
    },
};
INJECTABLES.$repeat = {
    schema: {},
    summon: function (injectees, component, node) {
        if (!injectees.$repeat) {
            injectees.$repeat = {};
        }
        var repeatNode = getRepeatHostNode(node);
        injectees.$repeat = (repeatNode && repeatNode.__memory.repeatee) || {
            instructions: [],
            payload: {},
            source: repeatNode,
            index: 0,
        };
    },
};
INJECTABLES.$if = {
    schema: {},
    summon: function (injectees, component, node) {
        if (!injectees.$if) {
            injectees.$if = {};
        }
        var ifNode = getIfHostNode(node);
        injectees.$if = (ifNode && ifNode.__memory.if) || {
            answer: null,
        };
    },
};
INJECTABLES.$placeholder = {
    schema: {},
    summon: function (injectees, component, node) {
        if (!injectees.$placeholder) {
            injectees.$placeholder = {};
        }
        injectees.$placeholder = node.__memory.placeholder || {
            value: null,
            surrogate: null,
        };
    },
};
INJECTABLES.$index = {
    schema: {},
    summon: function (injectees, component, node) {
        var repeatNode = getRepeatHostNode(node);
        injectees.$index = (repeatNode &&
            repeatNode.__memory.repeatee &&
            repeatNode.__memory.repeatee.index) || 0;
    },
};
INJECTABLES.$payload = {
    schema: {},
    summon: function (injectees, component, node) {
        var repeatNode = getRepeatHostNode(node);
        injectees.$payload = (repeatNode &&
            repeatNode.__memory.repeatee &&
            repeatNode.__memory.repeatee.payload) || {};
    },
};
INJECTABLES.$helpers = {
    schema: {
        now: 'function',
        rand: 'function',
        find: 'function',
    },
    summon: function (injectees, component) {
        injectees.$helpers = component.helpers;
    },
};
// List of JavaScript global built-in objects that we want to provide as an injectable.
// In the future, we might end up passing in modified versions of these objects/functions.
var BUILTIN_INJECTABLES = {
    Infinity: Infinity,
    NaN: NaN,
    Object: Object,
    Boolean: Boolean,
    Math: Math,
    Date: Date,
    JSON: JSON,
    Number: Number,
    String: String,
    RegExp: RegExp,
    Array: Array,
    isFinite: isFinite,
    isNaN: isNaN,
    parseFloat: parseFloat,
    parseInt: parseInt,
    decodeURI: decodeURI,
    decodeURIComponent: decodeURIComponent,
    encodeURI: encodeURI,
    encodeURIComponent: encodeURIComponent,
    // escape,
    // unescape,
    Error: Error,
    ReferenceError: ReferenceError,
    SyntaxError: SyntaxError,
    TypeError: TypeError,
    undefined: void (0),
};
var _loop_1 = function (builtinInjectableKey) {
    INJECTABLES[builtinInjectableKey] = {
        summon: function (injectees) {
            injectees[builtinInjectableKey] = BUILTIN_INJECTABLES[builtinInjectableKey];
        },
    };
};
for (var builtinInjectableKey in BUILTIN_INJECTABLES) {
    _loop_1(builtinInjectableKey);
}
/**
 * When evaluating expressions written by the user, don't crash everything.
 * Log the error (but only once, since we're animating) and then return a
 * fairly safe all-purpose value (1).
 */
var safeCall = function (fn, hostInstance, hostStates) {
    try {
        return fn.call(hostInstance, hostStates);
    }
    catch (exception) {
        consoleErrorOnce_1.default(exception);
        return 1;
    }
};
var safeApply = function (fn, hostInstance, summoneesArray) {
    try {
        return fn.apply(hostInstance, summoneesArray);
    }
    catch (exception) {
        consoleErrorOnce_1.default(exception);
        return 1;
    }
};
var areSummoneesDifferent = function (previous, incoming) {
    if (Array.isArray(previous) && Array.isArray(incoming)) {
        if (previous.length !== incoming.length) {
            return true;
        }
        // Do a shallow comparison of elements. We don't go deep because:
        //   - It easily becomes too expensive to do this while rendering
        //   - We can avoid needing to check for recursion
        for (var i = 0; i < previous.length; i++) {
            // Assume that objects are different since we don't want to do a deep comparison
            if (previous[i] && typeof previous[i] === 'object') {
                return true;
            }
            if (previous[i] !== incoming[i]) {
                return true;
            }
        }
        for (var j = 0; j < previous.length; j++) {
            // Assume that objects are different since we don't want to do a deep comparison
            if (incoming[j] && typeof incoming[j] === 'object') {
                return true;
            }
            if (incoming[j] !== previous[j]) {
                return true;
            }
        }
        return false;
    }
    if (typeof previous === OBJECT && typeof incoming === OBJECT) {
        if (previous === null && incoming === null) {
            return false;
        }
        if (previous === null) {
            return true;
        }
        if (incoming === null) {
            return true;
        }
        // Do a shallow comparison of properties. We don't go deep because:
        //   - It easily becomes too expensive to do this while rendering
        //   - We can avoid needing to check for recursion
        for (var pkey in previous) {
            if (previous[pkey] !== incoming[pkey]) {
                return true;
            }
        }
        for (var ikey in incoming) {
            if (incoming[ikey] !== previous[ikey]) {
                return true;
            }
        }
        return false;
    }
    return previous !== incoming;
};
var stringToInt = function (str) {
    var hash = 5381;
    var i = str.length;
    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0;
};
//# sourceMappingURL=HaikuComponent.js.map